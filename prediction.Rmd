# Prediction

## Prerequisites

```{r message = FALSE}
library("tidyverse")
library("lubridate")
library("stringr")
library("forcats")
qss_data_url <- function(chapter, file) {
  chapter_name <- stringr::str_to_upper(chapter)
  stringr::str_c("https://raw.githubusercontent.com/kosukeimai/qss/master/",
                 chapter_name, "/", file)
}
```
The packages `r pkg_link("modelr")` and `r pkg_link("broom")` are used to wrangle the results of linear regressions,
```{r message=FALSE}
library("broom")
library("modelr")
```


## Loops in R

For more on looping and iteration in R see the *R for Data Science* chapter [Iteration](http://r4ds.had.co.nz/data-visualisation.html).

RStudio provides many features to help debugging, which will be useful in
for loops and function: see  [this](https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio) article for an example.

## General Conditional Statements in R

See the *R for Data Science* section [Conditional Execution](http://r4ds.had.co.nz/functions.html#conditional-execution) for a more complete discussion of conditional execution.

If you are using conditional statements to assign values for data frame, 
see the **dplyr** functions `r rdoc("dplyr", "if_else")`, `r rdoc("dplyr", "recode")`, and `r rdoc("dplyr", "case_when")`


## Poll Predictions

Load the election polls and election results for 2008,
```{r polls08,message=FALSE}
polls08 <- read_csv(qss_data_url("UNCERTAINTY", "polls08.csv"))
glimpse(polls08)
```
```{r pres08,message=FALSE}
pres08 <- read_csv(qss_data_url("UNCERTAINTY", "pres08.csv"))
glimpse(pres08)
```

Compute Obama's margin in polls and final election
```{r polls08_margin}
polls08 <-
  polls08 %>% mutate(margin = Obama - McCain)
pres08 <- 
  pres08 %>% mutate(margin = Obama - McCain)
```

To work with dates, the R package `r pkg_link("lubridate")` makes wrangling them
much easier.
See the `r R4DS` chapter [Dates and Times](http://r4ds.had.co.nz/dates-and-times.html).

The function `r rdoc("lubridate", "ymd")` will convert character strings like `year-month-day` and more
into dates, as long as the order is (year, month, day). See `r rdoc("lubridate", "dmy")`, `r rdoc("lubridate", "ymd")`, and others for other ways to convert strings to dates.
```{r}
x <- ymd("2008-11-04")
y <- ymd("2008/9/1")
x - y
```

However, note that in `polls08`, the date `middate` is *already* a `date` object,
```{r}
class(polls08$middate)
```
The function `r rdoc("readr", "read_csv")` by default will check character vectors to see if they have patterns that appear to be dates, and if so, will
parse those columns as dates.

We'll create a variable for election day
```{r}
ELECTION_DAY <- ymd("2008-11-04")
```
and add a new column to `poll08` with the days to the election
```{r}
polls08 <-
  mutate(polls08, ELECTION_DAY - middate)
```

Although the code in the chapter uses a `for` loop, there is no reason to do so.
We can accomplish the same task by merging the election results data to the polling data by `state`.

```{r}
polls_w_results <- 
  left_join(polls08,
            select(pres08, state, elec_margin = margin),
            by = "state") %>%
  mutate(error = elec_margin - margin)
glimpse(polls_w_results)
```


To get the last poll in each state, arrange and filter on `middate`
```{r}
last_polls <- 
  polls_w_results %>%
  arrange(state, desc(middate)) %>%
  group_by(state) %>%
  slice(1)
last_polls
```


**Challenge:** Instead of using the last poll, use the average of polls in the last week? Last month? How do the margins on the polls change over the election period?

To simplify things for later, let's define a function `rmse` which calculates the root mean squared error, as defined in the book.
See the `r R4DS` chapter [Functions](http://r4ds.had.co.nz/functions.html) for more on writing functions.

```{r}
rmse <- function(actual, pred) {
  sqrt(mean((actual - pred) ^ 2))
}
```
Now we can use `rmse()` to calculate the RMSE for all the final polls:
```{r}
rmse(last_polls$margin, last_polls$elec_margin)
```
Or since we already have a variable `error`,
```{r}
sqrt(mean(last_polls$error ^ 2))
```
The mean prediction error is
```{r}
mean(last_polls$error)
```


This is slightly different than what is in the book due to the difference in the poll used as the final poll; many states have many polls on the last day.

I'll choose bin widths of 1%, since that is fairly interpretable:
```{r}
ggplot(last_polls, aes(x = error)) +
  geom_histogram(binwidth = 1, boundary = 0)
```

The text uses bin widths of 5%:
```{r}
ggplot(last_polls, aes(x = error)) +
  geom_histogram(binwidth = 5, boundary = 0)
```

**Challenge:** What other ways could you visualize the results? How would you show all states? What about plotting the absolute or squared errors instead of the errors?

**Challenge:** What happens to prediction error if you average polls?
Consider averaging back over time? 
What happens if you take the averages of the state poll average and average of **all** polls - does that improve prediction? 

To create a scatter plots using the state abbreviations instead of points use
`r ggdoc("geom_text")` instead of `r ggdoc("geom_point")`.
```{r}
ggplot(last_polls, aes(x = margin, y = elec_margin, label = state)) +
  geom_abline(color = "white", size = 2) +  
  geom_hline(yintercept = 0, color = "gray", size = 2) +
  geom_vline(xintercept = 0, color = "gray", size = 2) +
  geom_text() +
  coord_fixed() +
  labs(x = "Poll Results", y = "Actual Election Results")
```

We can create a confusion matrix as follows.
Create a new column `classification` which shows whether how the poll's classification was related to the actual election outcome ("true positive", "false positive", "false negative", "false positive").
If there were two outcomes, then we would use the `r RDoc("dplyr::if_then")` function. 
But with more than two outcomes, it is easier to use the `r pkg("dplyr")` function `r RDoc("dplyr::case_when")`.
```{r}
last_polls <-
  last_polls %>%
  ungroup() %>%
  mutate(classification = 
           case_when(
             (.$margin > 0 & .$elec_margin > 0) ~ "true positive",
             (.$margin > 0 & .$elec_margin < 0) ~ "false positive",
             (.$margin < 0 & .$elec_margin < 0) ~ "true negative",
             (.$margin < 0 & .$elec_margin > 0) ~ "false negative"
           ))
```
You need to use `.` to refer to the data frame when using `case_when` within `mutate()`.
Also, we needed to first use `r RDoc("ungroup")` in order to remove the grouping variable so `mutate` will work.

Now simply count the number of polls in each category of `classification`:
```{r}
last_polls %>%
  group_by(classification) %>%
  count()
```

Which states were incorrectly predicted by the polls?
```{r}
last_polls %>%
  filter(classification %in% c("false positive", "false negative")) %>%
  select(state, margin, elec_margin, classification) %>%
  arrange(desc(elec_margin))
```

What was the difference in the poll prediction of electoral votes and actual electoral votes. 
We hadn't included the variable `EV` when we first merged, but that's no problem, we'll just merge again in order to grab that variable:
```{r}
last_polls %>%
  left_join(select(pres08, state, EV), by = "state") %>%
  summarise(EV_pred = sum((margin > 0) * EV),
            EV_actual = sum((elec_margin > 0) * EV))
```

To look at predictions of the 

```{r message=FALSE}
# load the data
pollsUS08 <- read_csv(qss_data_url("prediction", "pollsUS08.csv")) %>%
  mutate(DaysToElection = ELECTION_DAY - middate)
```

We'll produce the seven-day averages slightly differently than the method used in the text. 
For all dates in the data, we'll calculate the moving average.
```{r}
all_dates <- seq(min(polls08$middate), ELECTION_DAY,
                 by = "days")

# Number of poll days to use
POLL_DAYS <- 7

pop_vote_avg <- vector(length(all_dates), mode = "list")
for (i in seq_along(all_dates)) {
  date <- all_dates[i]
  # summarise the seven day
  week_data <-
     pollsUS08 %>%
     filter(as.integer(middate - date) <= 0,
            as.integer(middate - date) > -POLL_DAYS) %>%
     summarise(Obama = mean(Obama, na.rm = TRUE),
               McCain = mean(McCain, na.rm = TRUE))
  # add date for the observation
  week_data$date <- date
  pop_vote_avg[[i]] <- week_data
}

pop_vote_avg <- bind_rows(pop_vote_avg)
```

It is easier to plot this if the data are tidy, with `Obama` and `McCain` as categories of a column `candidate`.
```{r}
pop_vote_avg_tidy <-
  pop_vote_avg %>% 
  gather(candidate, share, -date, na.rm = TRUE)
pop_vote_avg_tidy
```

```{r}
ggplot(pop_vote_avg_tidy, aes(x = date, y = share,
                              colour = forcats::fct_reorder2(candidate, date, share))) +
  geom_point() +
  geom_line() +
  scale_colour_manual("Candidate", 
                      values = c(Obama = "blue", McCain = "red"))
```


**Challenge** read `r R4DS` chapter [Iteration](http://r4ds.had.co.nz/iteration.html#the-map-functions) and use the function `r rdoc("purrr", "map_df")` instead of a for loop.

The 7-day average is similar to the simple method used by [Real Clear Politics](http://www.realclearpolitics.com/epolls/2016/president/us/general_election_trump_vs_clinton-5491.html). 
The RCP average is simply the average of all polls in their data for the last seven days.
Sites like [538](https://fivethirtyeight.com) and the [Huffpost Pollster](http://elections.huffingtonpost.com/pollster), on the other hand, also use what amounts to averaging polls, but using more sophisticated statistical methods to assign different weights to different polls.

**Challenge** Why do we need to use different polls for the popular vote data? Why not simply average all the state polls?
What would you have to do? 
Would the overall popular vote be useful in predicting state-level polling, or vice-versa? How would you use them?


## Linear Regression

### Facial Appearance and Election Outcomes

Load the `face` dataset:
```{r face,message=FALSE}
face <- read_csv(qss_data_url("prediction", "face.csv"))
```
Add Democrat and Republican vote shares, and the difference in shares:
```{r face_shares}
face <- mutate(face, 
                d.share = d.votes / (d.votes + r.votes),
                r.share = r.votes / (d.votes + r.votes),
                diff.share = d.share - r.share)
```

Plot facial competence vs. vote share:
```{r}
ggplot(face, aes(x = d.comp, y = diff.share, colour = w.party)) +
  geom_ref_line(h = 0) +
  geom_point() +
  scale_colour_manual("Winning\nParty",
                      values = c(D = "blue", R = "red")) +
  labs(x = "Competence scores for Democrats",
       y = "Democratic margin in vote share")
```


### Correlation

### Least Squares

Run the linear regression
```{r}
fit <- lm(diff.share ~ d.comp, data = face)
fit
```

There are many functions to get data out of the `lm` model.

In addition to these, the **broom** package provides three functions: `glance`, `tidy`, and `augment` that always return data frames.

The function `r rdoc("broom", "glance.lm", text="glance")` returns a one-row data-frame summary of the model,
```{r}
glance(fit)
```
The function `r rdoc("broom", "tidy.lm", text="tidy")` returns a data frame in which each row is a coefficient,
```{r}
tidy(fit)
```
The function `r rdoc("broom", "augment.lm", text="augment")` returns the original data with fitted values, residuals, and other observation level stats from the model appended to it.
```{r}
augment(fit) %>% head()
```


We can plot the results of the bivariate linear regression as follows:
```{r}
ggplot() +
  geom_point(data = face, mapping = aes(x = d.comp, y = diff.share)) +
  geom_abline(slope = coef(fit)["d.comp"],
              intercept = coef(fit)["(Intercept)"],
              colour = "red")
```

A more general way to plot the predictions of the model against the data 
is to use the methods described in [Ch 23.3.3](http://r4ds.had.co.nz/model-basics.html#visualising-models) of R4DS.
Create an evenly spaced grid of values of `d.comp`, and add predictions 
of the model to it.
```{r}
grid <- face %>%
  data_grid(d.comp) %>%
  add_predictions(fit)
head(grid)
```
Now we can plot the regression line and the original data just like any other plot.
```{r}
ggplot() +
  geom_point(data = face, mapping = aes(x = d.comp, y = diff.share)) +
  geom_line(data = grid, mapping = aes(x = d.comp, y = pred),
            colour = "red")
```
This method is more complicated than the `geom_abline` method for a bivariate regression, but will work for more complicated models, while the `geom_abline` method won't.


Note that `r ggdoc("geom_smooth")` can be used to add a regression line to a data-set.
```{r}
ggplot(data = face, mapping = aes(x = d.comp, y = diff.share)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```
The argument `method = "lm"` specifies that the function `lm` is to be used to generate fitted values. 
It is equivalent to running the regression `lm(y ~ x)` and plotting the regression line, where `y` and `x` are the aesthetics specified by the mappings.
The argument `se = FALSE` tells the function not to plot the confidence interval of the regression (discussed later).

### Regresion towards the mean

### Merging Data Sets in R

See the `r R4DS` chapter [Relational data](http://r4ds.had.co.nz/relational-data.html).

```{r pres12,message=FALSE}
pres12 <- read_csv(qss_data_url("prediction", "pres12.csv"))
```

```{r}
full_join(pres08, pres12, by = "state")
```

*Note: this could be a question. How would you change the .x, .y suffixes to something more informative*
To avoid the duplicate names, or change them, you can rename before merging, or
use the `suffix` argument:
```{r}
pres <- full_join(pres08, pres12, by = "state", suffix = c("_08", "_12"))
pres
```


The **dplyr** equivalent functions for `r rdoc("base", "cbind")` is `r rdoc("dplyr", "bind_cols")`.

```{r}
pres <- pres %>%
  mutate(Obama2008.z = scale(Obama_08),
         Obama2012.z = scale(Obama_12))
```

Scatter plot of states with vote shares in 2008 and 2012
```{r}
ggplot(pres, aes(x = Obama2008.z, y = Obama2012.z, label = state)) +
  geom_abline(colour = "white", size = 2) +
  geom_text() +
  coord_fixed() +
  scale_x_continuous("Obama's standardized vote share in 2008",
                     limits = c(-4, 4)) +  
  scale_y_continuous("Obama's standardized vote share in 2012",
                     limits = c(-4, 4))
```

To calculate the bottom and top quartiles

```{r}
pres %>%
  filter(Obama2008.z < quantile(Obama2008.z, 0.25)) %>%
  summarise(improve = mean(Obama2012.z > Obama2008.z))

pres %>%
  filter(Obama2008.z < quantile(Obama2008.z, 0.75)) %>%
  summarise(improve = mean(Obama2012.z > Obama2008.z))
```

**Challenge:** Why is it important to standardize the vote shares?

### Model Fit

```{r message=FALSE}
florida <- read_csv(qss_data_url("prediction", "florida.csv"))
fit2 <- lm(Buchanan00 ~ Perot96, data = florida)
fit2
```

In addition to
```{r}
summary(fit2)$r.squared
```
we can get the R squared value from the data frame `r rdoc("broom", "glance.lm", "glance")` returns:
```{r}
glance(fit2)
```

We can add predictions and residuals to the original data frame using the `r pkg_link("modelr")` functions `r rdoc("modelr", "add_residuals")` and `r rdoc("modelr", "add_predictions")`
```{r}
florida <-
  florida %>%
  add_predictions(fit2) %>%
  add_residuals(fit2)
glimpse(florida)
```
There are now two new columns in `florida`, `pred` with the fitted values (predictions), and `resid` with the residuals.

Use `fit2_augment` to create a residual plot:
```{r}
fit2_resid_plot <-
  ggplot(florida, aes(x = pred, y = resid)) +
  geom_ref_line(h = 0) +
  geom_point() +  
  labs(x = "Fitted values", y = "residuals")
fit2_resid_plot
```
Note, we use the function `r rdoc("modelr", "geom_refline")` to add a reference line at 0.

Let's add some labels to points, who is that outlier?
```{r}
fit2_resid_plot +
  geom_label(aes(label = county))
```

The outlier county is "Palm Beach"
```{r}
arrange(florida) %>%
  arrange(desc(abs(resid))) %>%
  select(county, resid) %>%
  head()
```

![Ted Mosby dressed as a Hanging Chad in "How I Met Your Mother"](./images/hanging-chad.png)

Data without Palm Beach
```{r}
florida_pb <- filter(florida, county != "PalmBeach")
fit3 <- lm(Buchanan00 ~ Perot96, data = florida_pb)
fit3
```

$R^2$ or coefficient of determination
```{r}
glance(fit3)
```

```{r}
florida_pb %>%
  add_residuals(fit3) %>%
  add_predictions(fit3) %>%
  ggplot(aes(x = pred, y = resid)) +
  geom_ref_line(h = 0) +
  geom_point() +
  ylim(-750, 2500) +
  xlim(0, 1500) +
  labs(x = "Fitted values", y = "residuals")
```

Create predictions for both models using `r rdoc("modelr", "data_grid")` and `r rdoc("modelr", "gather_predictions")`:
```{r}
florida_grid <-
  florida %>%
  data_grid(Perot96) %>%
  gather_predictions(fit2, fit3) %>%
  mutate(model =
           fct_recode(model,
                      "Regression\n with Palm Beach" = "fit2",
                      "Regression\n without Palm Beach" = "fit3"))
```
Note this is an example of using non-syntactic column names in a tibble, as discussed in Chapter 10 of [R for data science](http://r4ds.had.co.nz/tibbles.html).

```{r}
ggplot() +
  geom_point(data = florida, mapping = aes(x = Perot96, y = Buchanan00)) +
  geom_line(data = florida_grid, 
             mapping = aes(x = Perot96, y = pred, 
                           colour = model)) +
  geom_label(data = filter(florida, county == "PalmBeach"),
             mapping = aes(x = Perot96, y = Buchanan00, label = county),
                           vjust = "top", hjust = "right") +
  geom_text(data = tibble(label = unique(florida_grid$model),
                           x = c(20000, 31000),
                           y = c(1000, 300)),
             mapping = aes(x = x, y = y, label = label, colour = label)) +
  labs(x = "Perot's Vote in 1996", y = "Buchanan's Votes in 1996") +
  theme(legend.position = "none")
```
See [Graphics for communication](http://r4ds.had.co.nz/graphics-for-communication.html#label) in *R for Data Science* on labels and annotations in plots.



## Regression and Causation

Load data
```{r message=FALSE}
women <- read_csv(qss_data_url("prediction", "women.csv"))
```

proportion of female politicians in reserved GP vs. unreserved GP
```{r}
women %>%
  group_by(reserved) %>%
  summarise(prop_female = mean(female))
```

The diff in diff estimator
```{r}
## drinking-water facilities
 
## irrigation facilities
mean(women$irrigation[women$reserved == 1]) -
    mean(women$irrigation[women$reserved == 0])
```

Mean values of `irrigation` and `water` in reserved and non-reserved districts.
```{r}
women %>%
  group_by(reserved) %>%
  summarise(irrigation = mean(irrigation), 
            water = mean(water))
```

The difference between the two groups can be calculated with the function `r rdoc("base", "diff")`, which calculates the difference between subsequent observations.
This works as long as we are careful about which group is first or second.
```{r}
women %>%
  group_by(reserved) %>%
  summarise(irrigation = mean(irrigation), 
            water = mean(water)) %>%
  summarise(diff_irrigation = diff(irrigation),
            diff_water = diff(water))
```

The other way uses **tidyr** `r rdoc("tidyr", "spread.lm", "spread")` and `r rdoc("tidyr", "gather.lm", "gather")`,
```{r}
women %>%
  group_by(reserved) %>%
  summarise(irrigation = mean(irrigation), 
            water = mean(water)) %>%
  gather(variable, value, -reserved) %>%
  spread(reserved, value) %>%
  mutate(diff = `1` - `0`)
```
Now each row is an outcome variable of interest, and there are columns for the treatment (`1`) and control (`0`) groups, and the difference (`diff`).

```{r}
lm(water ~ reserved, data = women)
```
```{r}
lm(irrigation ~ reserved, data = women)
```

### Regression with multiple predictors

```{r message=FALSE}
social <- read_csv(qss_data_url("prediction", "social.csv"))
glimpse(social)
levels(social$messages)
fit <- lm(primary2008 ~ messages, data = social)
fit
```

Create indicator variables
```{r}
social <-
  social %>%
  mutate(Control = as.integer(messages == "Control"),
         Hawthorne = as.integer(messages == "Hawthorne"),
         Neighbors = as.integer(messages == "Neighbors"))
```
alternatively, create these using a for loop.
This is easier to understand and less prone to typo.
```{r}
for (i in unique(social$messages)) {
  social[[i]] <- as.integer(social[["messages"]] == i)
}
```
We created a variable for each level of `messages` even though we will exclude one of them.
```{r}
lm(primary2008 ~ Control + Hawthorne + Neighbors, data = social)
```

Create predictions for each unique value of `messages`
```{r}
unique_messages <- 
  data_grid(social, messages) %>%
  add_predictions(fit)
unique_messages
```

Compare to the sample averages
```{r}
social %>%
  group_by(messages) %>%
  summarise(mean(primary2008))
```

Linear regression without intercept.
```{r}
fit.noint <- lm(primary2008 ~ -1 + messages, data = social)
fit.noint
```

Calculating the regression average effect is also easier if we make the control group the first level so all regression coefficients are comparisons to it.
Use `r rdoc("forcats", "fct_relevel")` to make "Control"
```{r}
fit.control <- 
 mutate(social, messages = fct_relevel(messages, "Control")) %>%
 lm(primary2008 ~ messages, data = .)
fit.control
```

Difference in means
```{r}
social %>%
  group_by(messages) %>%
  summarise(primary2008 = mean(primary2008)) %>%
  mutate(Control = primary2008[messages == "Control"],
         diff = primary2008 - Control)
```

Adjusted R-squared is included in the output of `broom::glance()`
```{r}
glance(fit)
glance(fit)$adj.r.squared
```


### Heterogenous Treatment Effects

Average treatment effect (ate) among those who voted in 2004 primary
```{r}
ate <-
  social %>%
  group_by(primary2004, messages) %>%
  summarise(primary2008 = mean(primary2008)) %>%
  spread(messages, primary2008) %>%
  mutate(ate_Neighbors = Neighbors - Control) %>%
  select(primary2004, Neighbors, Control, ate_Neighbors)
ate
```
Difference in ATE in 2004 voters and non-voters
```{r}
diff(ate$ate_Neighbors)
```


```{r}
social.neighbor <- social %>%
  filter((messages == "Control") | (messages == "Neighbors"))

fit.int <- lm(primary2008 ~ primary2004 + messages + primary2004:messages,
              data = social.neighbor)
fit.int
```

```{r}
lm(primary2008 ~ primary2004 * messages, data = social.neighbor)
```

```{r}
social.neighbor <- 
  social.neighbor %>%
  mutate(age = 2008 - yearofbirth)

summary(social.neighbor$age)

fit.age <- lm(primary2008 ~ age * messages, data = social.neighbor)
fit.age
```

Calculate average treatment effects
```{r}
ate.age <-
  crossing(age = seq(from = 25, to = 85, by = 20),
         messages = c("Neighbors", "Control")) %>%
  add_predictions(fit.age) %>%
  spread(messages, pred) %>%
  mutate(diff = Neighbors - Control)
ate.age
```

You can use `r rdoc("base", "poly")` function to calculate polynomials instead of adding each term, `age + I(age ^ 2)`.
Though note that the coefficients will be be different since by default `poly` calculates orthogonal polynomials instead of the natural (raw) polynomials.
However, you really shouldn't interpret the coefficients directly anyways, so this should matter.
```{r}
fit.age2 <- lm(primary2008 ~ poly(age, 2) * messages,
               data = social.neighbor)
fit.age2
```

Create a data frame of combinations of ages and messages using `r rdoc("modelr", "data_grid")`, which means that we only need to specify the variables, and not the specific values,
```{r}
y.hat <-
  data_grid(social.neighbor, age, messages) %>%
  add_predictions(fit.age2)
```

```{r}
ggplot(y.hat, aes(x = age, y = pred, 
                  colour = str_c(messages, " condition"))) +
  geom_line() +
  labs(colour = "", y = "predicted turnout rates") +
  theme(legend.position = "bottom")
```

```{r}
y.hat %>%
  spread(messages, pred) %>%
  mutate(ate = Neighbors - Control) %>%
  filter(age > 20, age < 90) %>%
  ggplot(aes(x = age, y = ate)) +
  geom_line() +
  labs(y = "estimated average treatment effect") +
  ylim(0, 0.1)
```

## Regression Discontinuity Design

**Original code**
```{r eval=FALSE}
MPs <- read.csv("MPs.csv")
MPs.labour <- subset(MPs, subset = (party == "labour"))
MPs.tory <- subset(MPs, subset = (party == "tory"))
## two regressions for Labour: negative and positive margin
labour.fit1 <- lm(ln.net ~ margin, 
                  data = MPs.labour[MPs.labour$margin < 0, ])
labour.fit2 <- lm(ln.net ~ margin,
data = MPs.labour[MPs.labour$margin > 0, ]) ## two regressions for Tory: negative and positive margin
tory.fit1 <- lm(ln.net ~ margin, data = MPs.tory[MPs.tory$margin < 0, ])
tory.fit2 <- lm(ln.net ~ margin, data = MPs.tory[MPs.tory$margin > 0, ])
```

**Tidyverse**
```{r message=FALSE}
MPs <- read_csv(qss_data_url("prediction", "MPs.csv"))

MPs_labour <- filter(MPs, party == "labour")
MPs_tory <- filter(MPs, party == "tory")

labour_fit1 <- lm(ln.net ~ margin,
                 data = filter(MPs_labour, margin < 0))
labour_fit2 <- lm(ln.net ~ margin, MPs_labour, margin > 0)

tory_fit1 <- lm(ln.net ~ margin,
                data = filter(MPs_tory, margin < 0))
tory_fit2 <- lm(ln.net ~ margin, data = filter(MPs_tory, margin > 0))
```

**Original code**
```{r eval=FALSE}
## Labour: range of predictions
y1l.range <- c(min(MPs.labour$margin), 0) # min to 0
y2l.range <- c(0, max(MPs.labour$margin)) # 0 to max
## prediction
y1.labour <- predict(labour.fit1, newdata = data.frame(margin = y1l.range))
y2.labour <- predict(labour.fit2, newdata = data.frame(margin = y2l.range)) ## Tory: range of predictions
y1t.range <- c(min(MPs.tory$margin), 0) # min to 0
y2t.range <- c(0, max(MPs.tory$margin)) # 0 to max
## predict outcome
y1.tory <- predict(tory.fit1, newdata = data.frame(margin = y1t.range))
y2.tory <- predict(tory.fit2, newdata = data.frame(margin = y2t.range))
```

**Tidyverse code**

Use `r RDoc("modelr::data_grid")` to generate a grid for predictions.
```{r}
y1_labour <-
  filter(MPs_labour, margin < 0) %>%
  data_grid(margin) %>%
  add_predictions(labour_fit1)
y2_labour <-
  filter(MPs_labour, margin > 0) %>%
  data_grid(margin) %>%
  add_predictions(labour_fit2)

y1_tory <-
  filter(MPs_tory, margin < 0) %>%
  data_grid(margin) %>%
  add_predictions(tory_fit1)

y2_tory <-
  filter(MPs_tory, margin > 0) %>%
  data_grid(margin) %>%
  add_predictions(tory_fit2)
```

**Original code**
```{r eval=FALSE}
## scatterplot with regression lines for labour
plot(MPs.labour$margin, MPs.labour$ln.net, main = "Labour",
     xlim = c(-0.5, 0.5), ylim = c(6, 18), xlab = "margin of victory",
     ylab = "log net wealth at death")
abline(v = 0, lty = "dashed")
## add regression lines
lines(y1l.range, y1.labour, col = "red")
lines(y2l.range, y2.labour, col = "red")
## scatterplot with regression lines for tory
plot(MPs.tory$margin, MPs.tory$ln.net, main = "Tory", xlim = c(-0.5, 0.5),
     ylim = c(6, 18), xlab = "margin of victory",
ylab = "log net wealth at death") abline(v = 0, lty = "dashed")
## add regression lines
lines(y1t.range, y1.tory, col = "red")
lines(y2t.range, y2.tory, col = "red")
```

**Tidyverse code**

Labour politicians
```{r}
ggplot() +
  geom_ref_line(v = 0) +
  geom_point(data = MPs_labour,
            mapping = aes(x = margin, y = ln.net)) +
  geom_line(data = y1_labour,
            mapping = aes(x = margin, y = pred), colour = "red",
            size = 1.5) +
  geom_line(data = y2_labour,
            mapping = aes(x = margin, y = pred), colour = "red", size = 1.5) +
  labs(x = "margin of victory", y = "log net wealth at death",
       title = "Labour")
```

Tory politicians
```{r}
ggplot() +
  geom_ref_line(v = 0) +
  geom_point(data = MPs_tory,
             mapping = aes(x = margin, y = ln.net)) +
  geom_line(data = y1_tory,
            mapping = aes(x = margin, y = pred), colour = "red", size = 1.5) +
  geom_line(data = y2_tory,
            mapping = aes(x = margin, y = pred), colour = "red", size = 1.5) +
  labs(x = "margin of victory", y = "log net wealth at death",
       title = "labour")
```

We can actually produce this plot easily without running the regressions, by using `geom_smooth`:

```{r}
ggplot(mutate(MPs, winner = (margin > 0)),
       aes(x = margin, y = ln.net)) +
  geom_ref_line(v = 0) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE, mapping = aes(group = winner)) + 
  facet_grid(party ~ .) +
  labs(x = "margin of victory", y = "log net wealth at death")
```

**Original code**
```{r eval = FALSE}
## average net wealth for Tory MP
tory.MP <- exp(y2.tory[1])
tory.MP
##        1
## 533813.5
## average net wealth for Tory non-MP
tory.nonMP <- exp(y1.tory[2])
tory.nonMP
##        2
## 278762.5
## causal effect in pounds
tory.MP - tory.nonMP
##        1
## 255050.9
```

**Tidyverse:**
In the previous code, I didn't directly compute the the average net wealth at 0, so I'll need to do that here.
I'll use `r rdoc("modelr", "gather_predictions")` to add predictions for multiple models:
```{r}
spread_predictions(data_frame(margin = 0),
                   tory_fit1, tory_fit2) %>%
  mutate(rd_est = tory_fit2 - tory_fit1)
```


**Original:**
```{r eval = FALSE}
## two regressions for Tory: negative and positive margin
tory.fit3 <- lm(margin.pre ~ margin, data = MPs.tory[MPs.tory$margin < 0, ])
tory.fit4 <- lm(margin.pre ~ margin, data = MPs.tory[MPs.tory$margin > 0, ]) ## the difference between two intercepts is the estimated effect
coef(tory.fit4)[1] - coef(tory.fit3)[1]
## (Intercept)
## -0.01725578
```

**Tidyverse:**
```{r}
tory_fit3 <- lm(margin.pre ~ margin, data = filter(MPs_tory, margin < 0))
tory_fit4 <- lm(margin.pre ~ margin, data = filter(MPs_tory, margin > 0))

(filter(tidy(tory_fit3), term == "(Intercept)")[["estimate"]] -
 filter(tidy(tory_fit4), term == "(Intercept)")[["estimate"]])
```
