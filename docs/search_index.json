[
["prediction.html", "4 Prediction Prerequisites 4.1 Predicting Election Outcomes 4.2 Linear Regression 4.3 Regression and Causation", " 4 Prediction Prerequisites library(&quot;tidyverse&quot;) library(&quot;lubridate&quot;) library(&quot;stringr&quot;) library(&quot;forcats&quot;) The packages modelr and broom are used to wrangle the results of linear regressions, library(&quot;broom&quot;) library(&quot;modelr&quot;) 4.1 Predicting Election Outcomes 4.1.1 Loops in R RStudio provides many features to help debugging, which will be useful in for loops and function: see this article for an example. values &lt;- c(2, 3, 6) n &lt;- length(values) results &lt;- rep(NA, n) for (i in 1:n) { results[i] &lt;- values[i] * 2 cat(values[i], &quot;times 2 is equal to&quot;, results[i], &quot;\\n&quot;) } #&gt; 2 times 2 is equal to 4 #&gt; 3 times 2 is equal to 6 #&gt; 6 times 2 is equal to 12 Note that the above code uses the for loop for pedagogical purposes only, this could have simply been written results &lt;- values * 2 In general, avoid using for loops when there is a vectorized function. But sticking with the for loop, there are several things that could be improved. Avoid using the idiom 1:n in for loops. To see why, look what happens when values is empty: values &lt;- c() n &lt;- length(values) results &lt;- rep(NA, n) for (i in 1:n) { cat(&quot;i = &quot;, i, &quot;\\n&quot;) results[i] &lt;- values[i] * 2 cat(values[i], &quot;times 2 is equal to&quot;, results[i], &quot;\\n&quot;) } #&gt; i = 1 #&gt; times 2 is equal to NA #&gt; i = 0 #&gt; times 2 is equal to Instead of not running a loop, as you would expect, it runs two loops, where i = 1, then i = 0. This edge case occurs more than you may think, especially if you are writing functions where you don’t know the length of the vector is ex ante. The way to avoid this is to use either rdoc(&quot;base&quot;, &quot;seq_len&quot;) or rdoc(&quot;base&quot;, &quot;seq_along&quot;), which will handle 0-length vectors correctly. values &lt;- c() n &lt;- length(values) results &lt;- rep(NA, n) for (i in seq_along(values)) { results[i] &lt;- values[i] * 2 } print(results) #&gt; logical(0) or values &lt;- c() n &lt;- length(values) results &lt;- rep(NA, n) for (i in seq_len(n)) { results[i] &lt;- values[i] * 2 } print(results) #&gt; logical(0) Also, note that the the result is logical(0). That’s because the NA missing value has class logical, and thus rep(NA, ...) returns a logical vector. It is better style to initialize the vector with the same data type that you will be using, results &lt;- rep(NA_real_, length(values)) results #&gt; numeric(0) class(results) #&gt; [1] &quot;numeric&quot; Often loops can be rewritten to use a map function. Read the R for Data Science chapter Iteration before proceeding. For a functional, we first write a function that will be applied to each element of the vector. When converting from a for loop to a function, this is usually simply the body of the for loop, though you may need to add arguments for any variables defined outside the body of the for loop. In this case, mult_by_two &lt;- function(x) { x * 2 } We can now test that this function works on different values: mult_by_two(0) #&gt; [1] 0 mult_by_two(2.5) #&gt; [1] 5 mult_by_two(-3) #&gt; [1] -6 At this point, we could replace the body of the for loop with this function values &lt;- c(2, 4, 6) n &lt;- length(values) results &lt;- rep(NA, n) for (i in seq_len(n)) { results[i] &lt;- mult_by_two(values[i]) } print(results) #&gt; [1] 4 8 12 This can be useful if the body of a for loop is many lines long. However, this loop is still unwieldy code. We have to remember to define an empty vector results that is the same size as values to hold the results, and then correctly loop over all the values. We already saw how these steps have possibilities for errors. Functionals like map, apply a function to each element of a vector. results &lt;- map(values, mult_by_two) results #&gt; [[1]] #&gt; [1] 4 #&gt; #&gt; [[2]] #&gt; [1] 8 #&gt; #&gt; [[3]] #&gt; [1] 12 The values of each element are correct, but map returns a list vector, not a numeric vector like we may have been expecting. If we want a numeric vector, use map_dbl, results &lt;- map_dbl(values, mult_by_two) results #&gt; [1] 4 8 12 Also, instead of explicitly defining a function, like mult_by_two, we could have instead used an anonymous function with the functional. An anonymous function is a function that is not assigned to a name. results &lt;- map_dbl(values, function(x) x * 2) results #&gt; [1] 4 8 12 The various purrr functions also will interpret formulas as functions where .x and .y are interpreted as (up to) two arguments. results &lt;- map_dbl(values, ~ .x * 2) results #&gt; [1] 4 8 12 This is for parsimony and convenience; in the background, these functions are creating anonymous functions from the given formula. QSS discusses several debugging strategies. The functional approach lends itself to easier debugging because the function can be tested with input values independently of the loop. 4.1.2 General Conditional Statements in R See the R for Data Science section Conditional Execution for a more complete discussion of conditional execution. If you are using conditional statements to assign values for data frame, see the dplyr functions if_else, recode, and case_when The following code which uses a for loop, values &lt;- 1:5 n &lt;- length(values) results &lt;- rep(NA_real_, n) for (i in seq_len(n)) { x &lt;- values[i] r &lt;- x %% 2 if (r == 0) { cat(x, &quot;is even and I will perform addition&quot;, x, &quot; + &quot;, x, &quot;\\n&quot;) results[i] &lt;- x + x } else { cat(x, &quot;is even and I will perform multiplication&quot;, x, &quot; * &quot;, x, &quot;\\n&quot;) results[i] &lt;- x * x } } #&gt; 1 is even and I will perform multiplication 1 * 1 #&gt; 2 is even and I will perform addition 2 + 2 #&gt; 3 is even and I will perform multiplication 3 * 3 #&gt; 4 is even and I will perform addition 4 + 4 #&gt; 5 is even and I will perform multiplication 5 * 5 results #&gt; [1] 1 4 9 8 25 could be rewritten to use if_else, if_else(values %% 2 == 0, values + values, values * values) #&gt; [1] 1 4 9 8 25 or using the map_dbl functional with a named function, myfunc &lt;- function(x) { if (x %% 2 == 0) { x + x } else { x * x } } map_dbl(values, myfunc) #&gt; [1] 1 4 9 8 25 or map_dbl with an anonymous function, map_dbl(values, function(x) { if (x %% 2 == 0) { x + x } else { x * x } }) #&gt; [1] 1 4 9 8 25 4.1.3 Poll Predictions Load the election polls by state for the 2008 US Presidential election, data(&quot;polls08&quot;, package = &quot;qss&quot;) glimpse(polls08) #&gt; Observations: 1,332 #&gt; Variables: 5 #&gt; $ state &lt;chr&gt; &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;,... #&gt; $ Pollster &lt;chr&gt; &quot;SurveyUSA-2&quot;, &quot;Capital Survey-2&quot;, &quot;SurveyUSA-2&quot;, &quot;Ca... #&gt; $ Obama &lt;int&gt; 36, 34, 35, 35, 39, 34, 36, 25, 35, 34, 37, 36, 36, 3... #&gt; $ McCain &lt;int&gt; 61, 54, 62, 55, 60, 64, 58, 52, 55, 47, 55, 51, 49, 5... #&gt; $ middate &lt;date&gt; 2008-10-27, 2008-10-15, 2008-10-08, 2008-10-06, 2008... and the election results, data(&quot;pres08&quot;, package = &quot;qss&quot;) glimpse(pres08) #&gt; Observations: 51 #&gt; Variables: 5 #&gt; $ state.name &lt;chr&gt; &quot;Alabama&quot;, &quot;Alaska&quot;, &quot;Arizona&quot;, &quot;Arkansas&quot;, &quot;Califo... #&gt; $ state &lt;chr&gt; &quot;AL&quot;, &quot;AK&quot;, &quot;AZ&quot;, &quot;AR&quot;, &quot;CA&quot;, &quot;CO&quot;, &quot;CT&quot;, &quot;DC&quot;, &quot;DE... #&gt; $ Obama &lt;int&gt; 39, 38, 45, 39, 61, 54, 61, 92, 62, 51, 47, 72, 36,... #&gt; $ McCain &lt;int&gt; 60, 59, 54, 59, 37, 45, 38, 7, 37, 48, 52, 27, 62, ... #&gt; $ EV &lt;int&gt; 9, 3, 10, 6, 55, 9, 7, 3, 3, 27, 15, 4, 4, 21, 11, ... Compute Obama’s margin in polls and final election polls08 &lt;- polls08 %&gt;% mutate(margin = Obama - McCain) pres08 &lt;- pres08 %&gt;% mutate(margin = Obama - McCain) To work with dates, the R package lubridate makes wrangling them much easier. See the R for Data Science chapter Dates and Times. The function ymd will convert character strings like year-month-day and more into dates, as long as the order is (year, month, day). See dmy, ymd, and others for other ways to convert strings to dates. x &lt;- ymd(&quot;2008-11-04&quot;) y &lt;- ymd(&quot;2008/9/1&quot;) x - y #&gt; Time difference of 64 days However, note that in polls08, the date middate is already a date object, class(polls08$middate) #&gt; [1] &quot;Date&quot; The function read_csv by default will check character vectors to see if they have patterns that appear to be dates, and if so, will parse those columns as dates. We’ll create a variable for election day ELECTION_DAY &lt;- ymd(&quot;2008-11-04&quot;) and add a new column to poll08 with the days to the election polls08 &lt;- mutate(polls08, ELECTION_DAY - middate) Although the code in the chapter uses a for loop, there is no reason to do so. We can accomplish the same task by merging the election results data to the polling data by state. polls_w_results &lt;- left_join(polls08, select(pres08, state, elec_margin = margin), by = &quot;state&quot;) %&gt;% mutate(error = elec_margin - margin) glimpse(polls_w_results) #&gt; Observations: 1,332 #&gt; Variables: 9 #&gt; $ state &lt;chr&gt; &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;AL&quot;, &quot;... #&gt; $ Pollster &lt;chr&gt; &quot;SurveyUSA-2&quot;, &quot;Capital Survey-2&quot;, &quot;S... #&gt; $ Obama &lt;int&gt; 36, 34, 35, 35, 39, 34, 36, 25, 35, 3... #&gt; $ McCain &lt;int&gt; 61, 54, 62, 55, 60, 64, 58, 52, 55, 4... #&gt; $ middate &lt;date&gt; 2008-10-27, 2008-10-15, 2008-10-08, ... #&gt; $ margin &lt;int&gt; -25, -20, -27, -20, -21, -30, -22, -2... #&gt; $ `ELECTION_DAY - middate` &lt;time&gt; 8 days, 20 days, 27 days, 29 days, 4... #&gt; $ elec_margin &lt;int&gt; -21, -21, -21, -21, -21, -21, -21, -2... #&gt; $ error &lt;int&gt; 4, -1, 6, -1, 0, 9, 1, 6, -1, -8, -3,... To get the last poll in each state, arrange and filter on middate last_polls &lt;- polls_w_results %&gt;% arrange(state, desc(middate)) %&gt;% group_by(state) %&gt;% slice(1) last_polls #&gt; # A tibble: 51 x 9 #&gt; # Groups: state [51] #&gt; state Pollster Obama McCain middate margin `ELECT… elec… error #&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;date&gt; &lt;int&gt; &lt;time&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 AK Research 2000-3 39 58 2008-10-29 -19 6 -21 - 2 #&gt; 2 AL SurveyUSA-2 36 61 2008-10-27 -25 8 -21 4 #&gt; 3 AR ARG-4 44 51 2008-10-29 - 7 6 -20 -13 #&gt; 4 AZ ARG-3 46 50 2008-10-29 - 4 6 - 9 - 5 #&gt; 5 CA SurveyUSA-3 60 36 2008-10-30 24 5 24 0 #&gt; 6 CO ARG-3 52 45 2008-10-29 7 6 9 2 #&gt; # ... with 45 more rows Challenge: Instead of using the last poll, use the average of polls in the last week? Last month? How do the margins on the polls change over the election period? To simplify things for later, let’s define a function rmse which calculates the root mean squared error, as defined in the book. See the R for Data Science chapter Functions for more on writing functions. rmse &lt;- function(actual, pred) { sqrt(mean( (actual - pred) ^ 2)) } Now we can use rmse() to calculate the RMSE for all the final polls: rmse(last_polls$margin, last_polls$elec_margin) #&gt; [1] 5.88 Or since we already have a variable error, sqrt(mean(last_polls$error ^ 2)) #&gt; [1] 5.88 The mean prediction error is mean(last_polls$error) #&gt; [1] 1.08 This is slightly different than what is in the book due to the difference in the poll used as the final poll; many states have many polls on the last day. I’ll choose bin widths of 1%, since that is fairly interpretable: ggplot(last_polls, aes(x = error)) + geom_histogram(binwidth = 1, boundary = 0) The text uses bin widths of 5%: ggplot(last_polls, aes(x = error)) + geom_histogram(binwidth = 5, boundary = 0) Challenge: What other ways could you visualize the results? How would you show all states? What about plotting the absolute or squared errors instead of the errors? Challenge: What happens to prediction error if you average polls? Consider averaging back over time? What happens if you take the averages of the state poll average and average of all polls - does that improve prediction? To create a scatter plots using the state abbreviations instead of points use geom_text instead of geom_point. ggplot(last_polls, aes(x = margin, y = elec_margin, label = state)) + geom_abline(color = &quot;white&quot;, size = 2) + geom_hline(yintercept = 0, color = &quot;gray&quot;, size = 2) + geom_vline(xintercept = 0, color = &quot;gray&quot;, size = 2) + geom_text() + coord_fixed() + labs(x = &quot;Poll Results&quot;, y = &quot;Actual Election Results&quot;) We can create a confusion matrix as follows. Create a new column classification which shows whether how the poll’s classification was related to the actual election outcome (“true positive”, “false positive”, “false negative”, “false positive”). If there were two outcomes, then we would use the function. But with more than two outcomes, it is easier to use the dplyr function . last_polls &lt;- last_polls %&gt;% ungroup() %&gt;% mutate(classification = case_when( (.$margin &gt; 0 &amp; .$elec_margin &gt; 0) ~ &quot;true positive&quot;, (.$margin &gt; 0 &amp; .$elec_margin &lt; 0) ~ &quot;false positive&quot;, (.$margin &lt; 0 &amp; .$elec_margin &lt; 0) ~ &quot;true negative&quot;, (.$margin &lt; 0 &amp; .$elec_margin &gt; 0) ~ &quot;false negative&quot; )) You need to use . to refer to the data frame when using case_when within mutate(). Also, we needed to first use in order to remove the grouping variable so mutate will work. Now simply count the number of polls in each category of classification: last_polls %&gt;% group_by(classification) %&gt;% count() #&gt; # A tibble: 4 x 2 #&gt; # Groups: classification [4] #&gt; classification n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 false negative 2 #&gt; 2 false positive 1 #&gt; 3 true negative 21 #&gt; 4 true positive 27 Which states were incorrectly predicted by the polls, and what was their margins? last_polls %&gt;% filter(classification %in% c(&quot;false positive&quot;, &quot;false negative&quot;)) %&gt;% select(state, margin, elec_margin, classification) %&gt;% arrange(desc(elec_margin)) #&gt; # A tibble: 3 x 4 #&gt; state margin elec_margin classification #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; #&gt; 1 IN -5 1 false negative #&gt; 2 NC -1 1 false negative #&gt; 3 MO 1 -1 false positive What was the difference in the poll prediction of electoral votes and actual electoral votes. We hadn’t included the variable EV when we first merged, but that’s no problem, we’ll just merge again in order to grab that variable: last_polls %&gt;% left_join(select(pres08, state, EV), by = &quot;state&quot;) %&gt;% summarise(EV_pred = sum( (margin &gt; 0) * EV), EV_actual = sum( (elec_margin &gt; 0) * EV)) #&gt; # A tibble: 1 x 2 #&gt; EV_pred EV_actual #&gt; &lt;int&gt; &lt;int&gt; #&gt; 1 349 364 data(&quot;pollsUS08&quot;, package = &quot;qss&quot;) pollsUS08 &lt;- mutate(pollsUS08, DaysToElection = ELECTION_DAY - middate) We’ll produce the seven-day averages slightly differently than the method used in the text. For all dates in the data, we’ll calculate the moving average. The code presented in QSS uses a for loop similar to the following: all_dates &lt;- seq(min(polls08$middate), ELECTION_DAY, by = &quot;days&quot;) # Number of poll days to use POLL_DAYS &lt;- 7 pop_vote_avg &lt;- vector(length(all_dates), mode = &quot;list&quot;) for (i in seq_along(all_dates)) { date &lt;- all_dates[i] # summarise the seven day week_data &lt;- filter(polls08, as.integer(middate - date) &lt;= 0, as.integer(middate - date) &gt; - POLL_DAYS) %&gt;% summarise(Obama = mean(Obama, na.rm = TRUE), McCain = mean(McCain, na.rm = TRUE)) # add date for the observation week_data$date &lt;- date pop_vote_avg[[i]] &lt;- week_data } pop_vote_avg &lt;- bind_rows(pop_vote_avg) Write a function which takes a date, and calculates the days (the default is 7 days) moving average using the dataset .data: poll_ma &lt;- function(date, .data, days = 7) { filter(.data, as.integer(middate - date) &lt;= 0, as.integer(middate - date) &gt; - !!days) %&gt;% summarise(Obama = mean(Obama, na.rm = TRUE), McCain = mean(McCain, na.rm = TRUE)) %&gt;% mutate(date = !!date) } The code above uses !!. This tells filter that days refers to a variable days in the calling environment, and not a column named days in the data frame. In this case, there wouldn’t be any ambiguities since there is not a column named days, but in general there can be ambiguities in the dplyr functions as to whether the names refer to columns in the data frame or variables in the environment calling the function. Read Programming with dplyr for an in-depth discussion of this. This returns a one row data frame with the moving average for McCain and Obama on Nov 1, 2008. poll_ma(as.Date(&quot;2008-11-01&quot;), polls08) #&gt; Obama McCain date #&gt; 1 49.1 45.4 2008-11-01 Since we made days an argument to the function we could easily change the code to calculate other moving averages, poll_ma(as.Date(&quot;2008-11-01&quot;), polls08, days = 3) #&gt; Obama McCain date #&gt; 1 50.6 45.4 2008-11-01 Now use a functional to execute that function with all dates for which we want moving averages. The function poll_ma returns a data frame, and our ideal output is a data frame that stacks those data frames row-wise. So we will use the map_df function, map_df(all_dates, poll_ma, polls08) Note that the other arguments for poll_ma are placed after the name of the function as additional arguments to map_df. It is easier to plot this if the data are tidy, with Obama and McCain as categories of a column candidate. pop_vote_avg_tidy &lt;- pop_vote_avg %&gt;% gather(candidate, share, -date, na.rm = TRUE) head(pop_vote_avg_tidy) #&gt; date candidate share #&gt; 1 2008-01-01 Obama 46.5 #&gt; 2 2008-01-02 Obama 46.5 #&gt; 3 2008-01-03 Obama 46.5 #&gt; 4 2008-01-04 Obama 46.5 #&gt; 5 2008-01-05 Obama 46.5 #&gt; 6 2008-01-06 Obama 46.5 ggplot(pop_vote_avg_tidy, aes(x = date, y = share, colour = fct_reorder2(candidate, date, share))) + geom_point() + geom_line() + scale_colour_manual(&quot;Candidate&quot;, values = c(Obama = &quot;blue&quot;, McCain = &quot;red&quot;)) Challenge read R for Data Science chapter Iteration and use the function map_df instead of a for loop. The 7-day average is similar to the simple method used by Real Clear Politics. The RCP average is simply the average of all polls in their data for the last seven days. Sites like 538 and the Huffpost Pollster, on the other hand, also use what amounts to averaging polls, but using more sophisticated statistical methods to assign different weights to different polls. Challenge Why do we need to use different polls for the popular vote data? Why not simply average all the state polls? What would you have to do? Would the overall popular vote be useful in predicting state-level polling, or vice-versa? How would you use them? 4.2 Linear Regression 4.2.1 Facial Appearance and Election Outcomes Load the face dataset: data(&quot;face&quot;, package = &quot;qss&quot;) Add Democrat and Republican vote shares, and the difference in shares: face &lt;- mutate(face, d.share = d.votes / (d.votes + r.votes), r.share = r.votes / (d.votes + r.votes), diff.share = d.share - r.share) Plot facial competence vs. vote share: ggplot(face, aes(x = d.comp, y = diff.share, colour = w.party)) + geom_ref_line(h = 0) + geom_point() + scale_colour_manual(&quot;Winning\\nParty&quot;, values = c(D = &quot;blue&quot;, R = &quot;red&quot;)) + labs(x = &quot;Competence scores for Democrats&quot;, y = &quot;Democratic margin in vote share&quot;) 4.2.2 Correlation and Scatter Plots cor(face$d.comp, face$diff.share) #&gt; [1] 0.433 4.2.3 Least Squares Run the linear regression fit &lt;- lm(diff.share ~ d.comp, data = face) fit #&gt; #&gt; Call: #&gt; lm(formula = diff.share ~ d.comp, data = face) #&gt; #&gt; Coefficients: #&gt; (Intercept) d.comp #&gt; -0.312 0.660 There are many functions to get data out of the lm model. In addition to these, the broom package provides three functions: glance, tidy, and augment that always return data frames. The function glance returns a one-row data-frame summary of the model, glance(fit) #&gt; r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC #&gt; 1 0.187 0.18 0.266 27 8.85e-07 2 -10.5 27 35.3 #&gt; deviance df.residual #&gt; 1 8.31 117 The function tidy returns a data frame in which each row is a coefficient, tidy(fit) #&gt; term estimate std.error statistic p.value #&gt; 1 (Intercept) -0.312 0.066 -4.73 6.24e-06 #&gt; 2 d.comp 0.660 0.127 5.19 8.85e-07 The function augment returns the original data with fitted values, residuals, and other observation level stats from the model appended to it. augment(fit) %&gt;% head() #&gt; diff.share d.comp .fitted .se.fit .resid .hat .sigma .cooksd #&gt; 1 0.2101 0.565 0.0606 0.0266 0.1495 0.00996 0.267 0.001600 #&gt; 2 0.1194 0.342 -0.0864 0.0302 0.2059 0.01286 0.267 0.003938 #&gt; 3 0.0499 0.612 0.0922 0.0295 -0.0423 0.01229 0.268 0.000158 #&gt; 4 0.1965 0.542 0.0454 0.0256 0.1511 0.00922 0.267 0.001510 #&gt; 5 0.4958 0.680 0.1370 0.0351 0.3588 0.01737 0.266 0.016307 #&gt; 6 -0.3495 0.321 -0.1006 0.0319 -0.2490 0.01433 0.267 0.006436 #&gt; .std.resid #&gt; 1 0.564 #&gt; 2 0.778 #&gt; 3 -0.160 #&gt; 4 0.570 #&gt; 5 1.358 #&gt; 6 -0.941 We can plot the results of the bivariate linear regression as follows: ggplot() + geom_point(data = face, mapping = aes(x = d.comp, y = diff.share)) + geom_ref_line(v = mean(face$d.comp)) + geom_ref_line(h = mean(face$diff.share)) + geom_abline(slope = coef(fit)[&quot;d.comp&quot;], intercept = coef(fit)[&quot;(Intercept)&quot;], colour = &quot;red&quot;) + annotate(&quot;text&quot;, x = 0.9, y = mean(face$diff.share) + 0.05, label = &quot;Mean of Y&quot;, color = &quot;blue&quot;, vjust = 0) + annotate(&quot;text&quot;, y = -0.9, x = mean(face$d.comp), label = &quot;Mean of X&quot;, color = &quot;blue&quot;, hjust = 0) + scale_y_continuous(&quot;Democratic margin in vote shares&quot;, breaks = seq(-1, 1, by = 0.5), limits = c(-1, 1)) + scale_x_continuous(&quot;Democratic margin in vote shares&quot;, breaks = seq(0, 1, by = 0.2), limits = c(0, 1)) + ggtitle(&quot;Facial compotence and vote share&quot;) A more general way to plot the predictions of the model against the data is to use the methods described in Ch 23.3.3 of R4DS. Create an evenly spaced grid of values of d.comp, and add predictions of the model to it. grid &lt;- face %&gt;% data_grid(d.comp) %&gt;% add_predictions(fit) head(grid) #&gt; # A tibble: 6 x 2 #&gt; d.comp pred #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.0640 -0.270 #&gt; 2 0.0847 -0.256 #&gt; 3 0.0893 -0.253 #&gt; 4 0.115 -0.237 #&gt; 5 0.115 -0.236 #&gt; 6 0.164 -0.204 Now we can plot the regression line and the original data just like any other plot. ggplot() + geom_point(data = face, mapping = aes(x = d.comp, y = diff.share)) + geom_line(data = grid, mapping = aes(x = d.comp, y = pred), colour = &quot;red&quot;) This method is more complicated than the geom_abline method for a bivariate regression, but will work for more complicated models, while the geom_abline method won’t. Note that geom_smooth can be used to add a regression line to a data-set. ggplot(data = face, mapping = aes(x = d.comp, y = diff.share)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) The argument method = &quot;lm&quot; specifies that the function lm is to be used to generate fitted values. It is equivalent to running the regression lm(y ~ x) and plotting the regression line, where y and x are the aesthetics specified by the mappings. The argument se = FALSE tells the function not to plot the confidence interval of the regression (discussed later). 4.2.4 Regression towards the mean 4.2.5 Merging Data Sets in R See the R for Data Science chapter Relational data. data(&quot;pres12&quot;, package = &quot;qss&quot;) To join both data frames full_join(pres08, pres12, by = &quot;state&quot;) However, since there are duplicate names, .x and .y are appended. Challenge What would happen if by = &quot;state&quot; was dropped? To avoid the duplicate names, or change them, you can rename before merging, full_join(select(pres08, state, Obama_08 = Obama, McCain_08 = McCain, EV_08 = EV), select(pres12, state, Obama_12 = Obama, Romney_12 = Romney, EV_12 = EV), by = &quot;state&quot;) or use the suffix argument to full_join pres &lt;- full_join(pres08, pres12, by = &quot;state&quot;, suffix = c(&quot;_08&quot;, &quot;_12&quot;)) head(pres) #&gt; state.name state Obama_08 McCain EV_08 margin Obama_12 Romney EV_12 #&gt; 1 Alabama AL 39 60 9 -21 38 61 9 #&gt; 2 Alaska AK 38 59 3 -21 41 55 3 #&gt; 3 Arizona AZ 45 54 10 -9 45 54 11 #&gt; 4 Arkansas AR 39 59 6 -20 37 61 6 #&gt; 5 California CA 61 37 55 24 60 37 55 #&gt; 6 Colorado CO 54 45 9 9 51 46 9 Challenge Would you consider this data tidy? How would you make it tidy? The dplyr equivalent functions for cbind is bind_cols. pres &lt;- pres %&gt;% mutate(Obama2008_z = as.numeric(scale(Obama_08)), Obama2012_z = as.numeric(scale(Obama_12))) Likewise, bind_cols concatenates data frames by row. We need to use the as.numeric function because scale() always returns a matrix. This will not produce an error in the code chunk above, since the columns of a data frame can be matrices, but will produce errors in some of the following code if it were omitted. Scatter plot of states with vote shares in 2008 and 2012 ggplot(pres, aes(x = Obama2008_z, y = Obama2012_z, label = state)) + geom_abline(colour = &quot;white&quot;, size = 2) + geom_text() + coord_fixed() + scale_x_continuous(&quot;Obama&#39;s standardized vote share in 2008&quot;, limits = c(-4, 4)) + scale_y_continuous(&quot;Obama&#39;s standardized vote share in 2012&quot;, limits = c(-4, 4)) To calculate the bottom and top quartiles pres %&gt;% filter(Obama2008_z &lt; quantile(Obama2008_z, 0.25)) %&gt;% summarise(improve = mean(Obama2012_z &gt; Obama2008_z)) #&gt; improve #&gt; 1 0.583 pres %&gt;% filter(Obama2008_z &lt; quantile(Obama2008_z, 0.75)) %&gt;% summarise(improve = mean(Obama2012_z &gt; Obama2008_z)) #&gt; improve #&gt; 1 0.5 Challenge: Why is it important to standardize the vote shares? 4.2.6 Model Fit data(&quot;florida&quot;, package = &quot;qss&quot;) fit2 &lt;- lm(Buchanan00 ~ Perot96, data = florida) fit2 #&gt; #&gt; Call: #&gt; lm(formula = Buchanan00 ~ Perot96, data = florida) #&gt; #&gt; Coefficients: #&gt; (Intercept) Perot96 #&gt; 1.3458 0.0359 Calculate \\(R ^ 2\\) from the results of summary, summary(fit2)$r.squared #&gt; [1] 0.513 Alternatively, can get the R squared value from the data frame glance returns: glance(fit2) #&gt; r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC #&gt; 1 0.513 0.506 316 68.5 9.47e-12 2 -480 966 972 #&gt; deviance df.residual #&gt; 1 6506118 65 We can add predictions and residuals to the original data frame using the modelr functions add_residuals and add_predictions florida &lt;- florida %&gt;% add_predictions(fit2) %&gt;% add_residuals(fit2) glimpse(florida) #&gt; Observations: 67 #&gt; Variables: 9 #&gt; $ county &lt;chr&gt; &quot;Alachua&quot;, &quot;Baker&quot;, &quot;Bay&quot;, &quot;Bradford&quot;, &quot;Brevard&quot;, &quot;... #&gt; $ Clinton96 &lt;int&gt; 40144, 2273, 17020, 3356, 80416, 320736, 1794, 2712... #&gt; $ Dole96 &lt;int&gt; 25303, 3684, 28290, 4038, 87980, 142834, 1717, 2783... #&gt; $ Perot96 &lt;int&gt; 8072, 667, 5922, 819, 25249, 38964, 630, 7783, 7244... #&gt; $ Bush00 &lt;int&gt; 34124, 5610, 38637, 5414, 115185, 177323, 2873, 354... #&gt; $ Gore00 &lt;int&gt; 47365, 2392, 18850, 3075, 97318, 386561, 2155, 2964... #&gt; $ Buchanan00 &lt;int&gt; 263, 73, 248, 65, 570, 788, 90, 182, 270, 186, 122,... #&gt; $ pred &lt;dbl&gt; 291.3, 25.3, 214.0, 30.8, 908.2, 1400.7, 24.0, 280.... #&gt; $ resid &lt;dbl&gt; -2.83e+01, 4.77e+01, 3.40e+01, 3.42e+01, -3.38e+02,... There are now two new columns in florida, pred with the fitted values (predictions), and resid with the residuals. Use fit2_augment to create a residual plot: fit2_resid_plot &lt;- ggplot(florida, aes(x = pred, y = resid)) + geom_ref_line(h = 0) + geom_point() + labs(x = &quot;Fitted values&quot;, y = &quot;residuals&quot;) fit2_resid_plot Note, we use the function geom_refline to add a reference line at 0. Let’s add some labels to points, who is that outlier? fit2_resid_plot + geom_label(aes(label = county)) The outlier county is “Palm Beach” arrange(florida) %&gt;% arrange(desc(abs(resid))) %&gt;% select(county, resid) %&gt;% head() #&gt; county resid #&gt; 1 PalmBeach 2302 #&gt; 2 Broward -613 #&gt; 3 Lee -357 #&gt; 4 Brevard -338 #&gt; 5 Miami-Dade -329 #&gt; 6 Pinellas -317 Data without Palm Beach florida_pb &lt;- filter(florida, county != &quot;PalmBeach&quot;) fit3 &lt;- lm(Buchanan00 ~ Perot96, data = florida_pb) fit3 #&gt; #&gt; Call: #&gt; lm(formula = Buchanan00 ~ Perot96, data = florida_pb) #&gt; #&gt; Coefficients: #&gt; (Intercept) Perot96 #&gt; 45.8419 0.0244 \\(R^2\\) or coefficient of determination glance(fit3) #&gt; r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC #&gt; 1 0.851 0.849 87.7 366 3.61e-28 2 -388 782 788 #&gt; deviance df.residual #&gt; 1 492803 64 florida_pb %&gt;% add_residuals(fit3) %&gt;% add_predictions(fit3) %&gt;% ggplot(aes(x = pred, y = resid)) + geom_ref_line(h = 0) + geom_point() + ylim(-750, 2500) + xlim(0, 1500) + labs(x = &quot;Fitted values&quot;, y = &quot;residuals&quot;) Create predictions for both models using data_grid and gather_predictions: florida_grid &lt;- florida %&gt;% data_grid(Perot96) %&gt;% gather_predictions(fit2, fit3) %&gt;% mutate(model = fct_recode(model, &quot;Regression\\n with Palm Beach&quot; = &quot;fit2&quot;, &quot;Regression\\n without Palm Beach&quot; = &quot;fit3&quot;)) Note this is an example of using non-syntactic column names in a tibble, as discussed in Chapter 10 of R for data science. ggplot() + geom_point(data = florida, mapping = aes(x = Perot96, y = Buchanan00)) + geom_line(data = florida_grid, mapping = aes(x = Perot96, y = pred, colour = model)) + geom_label(data = filter(florida, county == &quot;PalmBeach&quot;), mapping = aes(x = Perot96, y = Buchanan00, label = county), vjust = &quot;top&quot;, hjust = &quot;right&quot;) + geom_text(data = tibble(label = unique(florida_grid$model), x = c(20000, 31000), y = c(1000, 300)), mapping = aes(x = x, y = y, label = label, colour = label)) + labs(x = &quot;Perot&#39;s Vote in 1996&quot;, y = &quot;Buchanan&#39;s Votes in 1996&quot;) + theme(legend.position = &quot;none&quot;) See Graphics for communication in R for Data Science on labels and annotations in plots. 4.3 Regression and Causation 4.3.1 Randomized Experiments Load data data(&quot;women&quot;, package = &quot;qss&quot;) proportion of female politicians in reserved GP vs. unreserved GP women %&gt;% group_by(reserved) %&gt;% summarise(prop_female = mean(female)) #&gt; # A tibble: 2 x 2 #&gt; reserved prop_female #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 0 0.0748 #&gt; 2 1 1.00 The diff in diff estimator # drinking water facilities # irrigation facilities mean(women$irrigation[women$reserved == 1]) - mean(women$irrigation[women$reserved == 0]) #&gt; [1] -0.369 Mean values of irrigation and water in reserved and non-reserved districts. women %&gt;% group_by(reserved) %&gt;% summarise(irrigation = mean(irrigation), water = mean(water)) #&gt; # A tibble: 2 x 3 #&gt; reserved irrigation water #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 3.39 14.7 #&gt; 2 1 3.02 24.0 The difference between the two groups can be calculated with the function diff, which calculates the difference between subsequent observations. This works as long as we are careful about which group is first or second. women %&gt;% group_by(reserved) %&gt;% summarise(irrigation = mean(irrigation), water = mean(water)) %&gt;% summarise(diff_irrigation = diff(irrigation), diff_water = diff(water)) #&gt; # A tibble: 1 x 2 #&gt; diff_irrigation diff_water #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 -0.369 9.25 The other way uses tidyr spread and gather, women %&gt;% group_by(reserved) %&gt;% summarise(irrigation = mean(irrigation), water = mean(water)) %&gt;% gather(variable, value, -reserved) %&gt;% spread(reserved, value) %&gt;% mutate(diff = `1` - `0`) #&gt; # A tibble: 2 x 4 #&gt; variable `0` `1` diff #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 irrigation 3.39 3.02 -0.369 #&gt; 2 water 14.7 24.0 9.25 Now each row is an outcome variable of interest, and there are columns for the treatment (1) and control (0) groups, and the difference (diff). lm(water ~ reserved, data = women) #&gt; #&gt; Call: #&gt; lm(formula = water ~ reserved, data = women) #&gt; #&gt; Coefficients: #&gt; (Intercept) reserved #&gt; 14.74 9.25 lm(irrigation ~ reserved, data = women) #&gt; #&gt; Call: #&gt; lm(formula = irrigation ~ reserved, data = women) #&gt; #&gt; Coefficients: #&gt; (Intercept) reserved #&gt; 3.388 -0.369 4.3.2 Regression with multiple predictors data(&quot;social&quot;, package = &quot;qss&quot;) glimpse(social) #&gt; Observations: 305,866 #&gt; Variables: 6 #&gt; $ sex &lt;chr&gt; &quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;mal... #&gt; $ yearofbirth &lt;int&gt; 1941, 1947, 1951, 1950, 1982, 1981, 1959, 1956, 19... #&gt; $ primary2004 &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0,... #&gt; $ messages &lt;chr&gt; &quot;Civic Duty&quot;, &quot;Civic Duty&quot;, &quot;Hawthorne&quot;, &quot;Hawthorn... #&gt; $ primary2006 &lt;int&gt; 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1,... #&gt; $ hhsize &lt;int&gt; 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 1, 2, 2, 1, 2, 2, 1,... levels(social$messages) #&gt; NULL fit &lt;- lm(primary2006 ~ messages, data = social) fit #&gt; #&gt; Call: #&gt; lm(formula = primary2006 ~ messages, data = social) #&gt; #&gt; Coefficients: #&gt; (Intercept) messagesControl messagesHawthorne #&gt; 0.31454 -0.01790 0.00784 #&gt; messagesNeighbors #&gt; 0.06341 Create indicator variables for each message: social &lt;- social %&gt;% mutate(Control = as.integer(messages == &quot;Control&quot;), Hawthorne = as.integer(messages == &quot;Hawthorne&quot;), Neighbors = as.integer(messages == &quot;Neighbors&quot;)) alternatively, create these using a for loop. This is easier to understand and less prone to typos: for (i in unique(social$messages)) { social[[i]] &lt;- as.integer(social[[&quot;messages&quot;]] == i) } We created a variable for each level of messages even though we will exclude one of them. lm(primary2006 ~ Control + Hawthorne + Neighbors, data = social) #&gt; #&gt; Call: #&gt; lm(formula = primary2006 ~ Control + Hawthorne + Neighbors, data = social) #&gt; #&gt; Coefficients: #&gt; (Intercept) Control Hawthorne Neighbors #&gt; 0.31454 -0.01790 0.00784 0.06341 Create predictions for each unique value of messages unique_messages &lt;- data_grid(social, messages) %&gt;% add_predictions(fit) unique_messages #&gt; # A tibble: 4 x 2 #&gt; messages pred #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Civic Duty 0.315 #&gt; 2 Control 0.297 #&gt; 3 Hawthorne 0.322 #&gt; 4 Neighbors 0.378 Compare to the sample averages social %&gt;% group_by(messages) %&gt;% summarise(mean(primary2006)) #&gt; # A tibble: 4 x 2 #&gt; messages `mean(primary2006)` #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Civic Duty 0.315 #&gt; 2 Control 0.297 #&gt; 3 Hawthorne 0.322 #&gt; 4 Neighbors 0.378 Linear regression without intercept. fit.noint &lt;- lm(primary2006 ~ -1 + messages, data = social) fit.noint #&gt; #&gt; Call: #&gt; lm(formula = primary2006 ~ -1 + messages, data = social) #&gt; #&gt; Coefficients: #&gt; messagesCivic Duty messagesControl messagesHawthorne #&gt; 0.315 0.297 0.322 #&gt; messagesNeighbors #&gt; 0.378 Calculating the regression average effect is also easier if we make the control group the first level so all regression coefficients are comparisons to it. Use fct_relevel to make “Control” fit.control &lt;- mutate(social, messages = fct_relevel(messages, &quot;Control&quot;)) %&gt;% lm(primary2006 ~ messages, data = .) fit.control #&gt; #&gt; Call: #&gt; lm(formula = primary2006 ~ messages, data = .) #&gt; #&gt; Coefficients: #&gt; (Intercept) messagesCivic Duty messagesHawthorne #&gt; 0.2966 0.0179 0.0257 #&gt; messagesNeighbors #&gt; 0.0813 Difference in means social %&gt;% group_by(messages) %&gt;% summarise(primary2006 = mean(primary2006)) %&gt;% mutate(Control = primary2006[messages == &quot;Control&quot;], diff = primary2006 - Control) #&gt; # A tibble: 4 x 4 #&gt; messages primary2006 Control diff #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Civic Duty 0.315 0.297 0.0179 #&gt; 2 Control 0.297 0.297 0 #&gt; 3 Hawthorne 0.322 0.297 0.0257 #&gt; 4 Neighbors 0.378 0.297 0.0813 Adjusted R-squared is included in the output of broom::glance() glance(fit) #&gt; r.squared adj.r.squared sigma statistic p.value df logLik AIC #&gt; 1 0.00328 0.00327 0.463 336 1.06e-217 4 -198247 396504 #&gt; BIC deviance df.residual #&gt; 1 396557 65468 305862 glance(fit)[[&quot;adj.r.squared&quot;]] #&gt; [1] 0.00327 4.3.3 Heterogeneous Treatment Effects Average treatment effect (ate) among those who voted in 2004 primary ate &lt;- social %&gt;% group_by(primary2004, messages) %&gt;% summarise(primary2006 = mean(primary2006)) %&gt;% spread(messages, primary2006) %&gt;% mutate(ate_Neighbors = Neighbors - Control) %&gt;% select(primary2004, Neighbors, Control, ate_Neighbors) ate #&gt; # A tibble: 2 x 4 #&gt; # Groups: primary2004 [2] #&gt; primary2004 Neighbors Control ate_Neighbors #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0.306 0.237 0.0693 #&gt; 2 1 0.482 0.386 0.0965 Difference in ATE in 2004 voters and non-voters diff(ate$ate_Neighbors) #&gt; [1] 0.0272 social.neighbor &lt;- social %&gt;% filter( (messages == &quot;Control&quot;) | (messages == &quot;Neighbors&quot;)) fit.int &lt;- lm(primary2006 ~ primary2004 + messages + primary2004:messages, data = social.neighbor) fit.int #&gt; #&gt; Call: #&gt; lm(formula = primary2006 ~ primary2004 + messages + primary2004:messages, #&gt; data = social.neighbor) #&gt; #&gt; Coefficients: #&gt; (Intercept) primary2004 #&gt; 0.2371 0.1487 #&gt; messagesNeighbors primary2004:messagesNeighbors #&gt; 0.0693 0.0272 lm(primary2006 ~ primary2004 * messages, data = social.neighbor) #&gt; #&gt; Call: #&gt; lm(formula = primary2006 ~ primary2004 * messages, data = social.neighbor) #&gt; #&gt; Coefficients: #&gt; (Intercept) primary2004 #&gt; 0.2371 0.1487 #&gt; messagesNeighbors primary2004:messagesNeighbors #&gt; 0.0693 0.0272 social.neighbor &lt;- social.neighbor %&gt;% mutate(age = 2008 - yearofbirth) summary(social.neighbor$age) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 22.0 43.0 52.0 51.8 61.0 108.0 fit.age &lt;- lm(primary2006 ~ age * messages, data = social.neighbor) fit.age #&gt; #&gt; Call: #&gt; lm(formula = primary2006 ~ age * messages, data = social.neighbor) #&gt; #&gt; Coefficients: #&gt; (Intercept) age messagesNeighbors #&gt; 0.089477 0.003998 0.048573 #&gt; age:messagesNeighbors #&gt; 0.000628 Calculate average treatment effects ate.age &lt;- crossing(age = seq(from = 25, to = 85, by = 20), messages = c(&quot;Neighbors&quot;, &quot;Control&quot;)) %&gt;% add_predictions(fit.age) %&gt;% spread(messages, pred) %&gt;% mutate(diff = Neighbors - Control) ate.age #&gt; # A tibble: 4 x 4 #&gt; age Control Neighbors diff #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 25.0 0.189 0.254 0.0643 #&gt; 2 45.0 0.269 0.346 0.0768 #&gt; 3 65.0 0.349 0.439 0.0894 #&gt; 4 85.0 0.429 0.531 0.102 You can use poly function to calculate polynomials instead of adding each term, age + I(age ^ 2). Though note that the coefficients will be be different since by default poly calculates orthogonal polynomials instead of the natural (raw) polynomials. However, you really shouldn’t interpret the coefficients directly anyways, so this should matter. fit.age2 &lt;- lm(primary2006 ~ poly(age, 2) * messages, data = social.neighbor) fit.age2 #&gt; #&gt; Call: #&gt; lm(formula = primary2006 ~ poly(age, 2) * messages, data = social.neighbor) #&gt; #&gt; Coefficients: #&gt; (Intercept) poly(age, 2)1 #&gt; 0.2966 27.6665 #&gt; poly(age, 2)2 messagesNeighbors #&gt; -10.2832 0.0816 #&gt; poly(age, 2)1:messagesNeighbors poly(age, 2)2:messagesNeighbors #&gt; 4.5820 -5.5124 Create a data frame of combinations of ages and messages using data_grid, which means that we only need to specify the variables, and not the specific values, y.hat &lt;- data_grid(social.neighbor, age, messages) %&gt;% add_predictions(fit.age2) ggplot(y.hat, aes(x = age, y = pred, colour = str_c(messages, &quot; condition&quot;))) + geom_line() + labs(colour = &quot;&quot;, y = &quot;Predicted turnout rates&quot;) + theme(legend.position = &quot;bottom&quot;) y.hat %&gt;% spread(messages, pred) %&gt;% mutate(ate = Neighbors - Control) %&gt;% filter(age &gt; 20, age &lt; 90) %&gt;% ggplot(aes(x = age, y = ate)) + geom_line() + labs(y = &quot;Estimated average treatment effect&quot;, x = &quot;Age&quot;) + ylim(0, 0.1) 4.3.4 Regression Discontinuity Design data(&quot;MPs&quot;, package = &quot;qss&quot;) MPs_labour &lt;- filter(MPs, party == &quot;labour&quot;) MPs_tory &lt;- filter(MPs, party == &quot;tory&quot;) labour_fit1 &lt;- lm(ln.net ~ margin, data = filter(MPs_labour, margin &lt; 0)) labour_fit2 &lt;- lm(ln.net ~ margin, MPs_labour, margin &gt; 0) tory_fit1 &lt;- lm(ln.net ~ margin, data = filter(MPs_tory, margin &lt; 0)) tory_fit2 &lt;- lm(ln.net ~ margin, data = filter(MPs_tory, margin &gt; 0)) Use to generate a grid for predictions. y1_labour &lt;- filter(MPs_labour, margin &lt; 0) %&gt;% data_grid(margin) %&gt;% add_predictions(labour_fit1) y2_labour &lt;- filter(MPs_labour, margin &gt; 0) %&gt;% data_grid(margin) %&gt;% add_predictions(labour_fit2) y1_tory &lt;- filter(MPs_tory, margin &lt; 0) %&gt;% data_grid(margin) %&gt;% add_predictions(tory_fit1) y2_tory &lt;- filter(MPs_tory, margin &gt; 0) %&gt;% data_grid(margin) %&gt;% add_predictions(tory_fit2) Tory politicians ggplot() + geom_ref_line(v = 0) + geom_point(data = MPs_tory, mapping = aes(x = margin, y = ln.net)) + geom_line(data = y1_tory, mapping = aes(x = margin, y = pred), colour = &quot;red&quot;, size = 1.5) + geom_line(data = y2_tory, mapping = aes(x = margin, y = pred), colour = &quot;red&quot;, size = 1.5) + labs(x = &quot;margin of victory&quot;, y = &quot;log net wealth at death&quot;, title = &quot;labour&quot;) We can actually produce this plot easily without running the regressions, by using geom_smooth: ggplot(mutate(MPs, winner = (margin &gt; 0)), aes(x = margin, y = ln.net)) + geom_ref_line(v = 0) + geom_point() + geom_smooth(method = lm, se = FALSE, mapping = aes(group = winner)) + facet_grid(party ~ .) + labs(x = &quot;margin of victory&quot;, y = &quot;log net wealth at death&quot;) In the previous code, I didn’t directly compute the the average net wealth at 0, so I’ll need to do that here. I’ll use gather_predictions to add predictions for multiple models: spread_predictions(data_frame(margin = 0), tory_fit1, tory_fit2) %&gt;% mutate(rd_est = tory_fit2 - tory_fit1) #&gt; # A tibble: 1 x 4 #&gt; margin tory_fit1 tory_fit2 rd_est #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 12.5 13.2 0.650 tory_fit3 &lt;- lm(margin.pre ~ margin, data = filter(MPs_tory, margin &lt; 0)) tory_fit4 &lt;- lm(margin.pre ~ margin, data = filter(MPs_tory, margin &gt; 0)) (filter(tidy(tory_fit3), term == &quot;(Intercept)&quot;)[[&quot;estimate&quot;]] - filter(tidy(tory_fit4), term == &quot;(Intercept)&quot;)[[&quot;estimate&quot;]]) #&gt; [1] 0.0173 "]
]
