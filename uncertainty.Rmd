# Uncertainty

## Prerequisites

We will use these package in this chapter:
```{r message=FALSE}
library("tidyverse")
library("forcats")
library("lubridate")
library("stringr")
library("modelr")
library("broom")
```


## Estimation

```{r}
n <- 100
mu0 <- 0
sd0 <- 1
mu1 <- 1
sd1 <- 1
smpl <- tibble(id = seq_len(n),
               Y0 = rnorm(n, mean = mu0, sd = sd0),
               Y1 = rnorm(n, mean = mu1, sd = sd1),
               tau = Y1 - Y0)
SATE <- mean(smpl[["tau"]])
SATE
```


```{r}
sims <- 5000

sim_treat <- function(smpl) {
  SATE <- mean(smpl[["tau"]])
  # indexes of obs receiving treatment
  idx <- sample(seq_len(n), floor(nrow(smpl) / 2), replace = FALSE)
  # treat variable are those receiving treatment, else 0
  smpl[["treat"]] <- as.integer(seq_len(nrow(smpl)) %in% idx)
  smpl %>%
    mutate(Y_obs = if_else(treat == 1L, Y1, Y0)) %>%
    group_by(treat) %>%
    summarise(Y_obs = mean(Y_obs)) %>%
    spread(treat, Y_obs) %>%
    mutate(diff = `1` - `0`,
           est_error = diff - SATE)
}

diff_means <- map_df(seq_len(sims), ~ sim_treat(smpl))
summary(diff_means[["est_error"]])
```

```{r}
PATE <- mu1 - mu0

sim_pate <- function(mu0, mu1, sd0, sd1) {
  PATE <- mu1 - mu0
  smpl <- tibble(Y0 = rnorm(n, mean = mu0, sd = sd0),
                 Y1 = rnorm(n, mean = mu1, sd = sd1),
                 tau = Y1 - Y0)
  # indexes of obs receiving treatment
  idx <- sample(seq_len(n), floor(nrow(smpl) / 2), replace = FALSE)
  # treat variable are those receiving treatment, else 0
  smpl[["treat"]] <- as.integer(seq_len(nrow(smpl)) %in% idx)
  smpl %>%
    mutate(Y_obs = if_else(treat == 1L, Y1, Y0)) %>%
    group_by(treat) %>%
    summarise(Y_obs = mean(Y_obs)) %>%
    spread(treat, Y_obs) %>%
    mutate(diff = `1` - `0`,
           est_error = diff - PATE)
}

diff_means <-
  map_df(seq_len(sims), ~ sim_pate(mu0, mu1, sd0, sd1)) 

summary(diff_means[["est_error"]])

```

### Standard Errors

```{r}
ggplot(diff_means, aes(x = diff)) +
  geom_histogram() +
  geom_vline(xintercept = PATE, colour = "white", size = 2) +
  ggtitle("sampling distribution")
```


```{r}
sim_pate_se <- function(mu0, mu1, sd0, sd1) {
  PATE <- mu1 - mu0
  smpl <- tibble(Y0 = rnorm(n, mean = mu0, sd = sd0),
                 Y1 = rnorm(n, mean = mu1, sd = sd1),
                 tau = Y1 - Y0)
  # indexes of obs receiving treatment
  idx <- sample(seq_len(n), floor(nrow(smpl) / 2), replace = FALSE)
  # treat variable are those receiving treatment, else 0
  smpl[["treat"]] <- as.integer(seq_len(nrow(smpl)) %in% idx)
  smpl %>%
    mutate(Y_obs = if_else(treat == 1L, Y1, Y0)) %>%
    group_by(treat) %>%
    summarise(mean = mean(Y_obs), var = var(Y_obs),
              nobs = n()) %>%
    summarise(diff_mean = diff(mean), 
              se = sqrt(sum(var / nobs)),
              est_error = diff_mean - PATE)
}
diff_means <-
  map_df(seq_len(sims), ~ sim_pate_se(mu0, mu1, sd0, sd1)) 
```
```{r}
summary(diff_means[["se"]])
```

### Confidence Intervals

**tidyverse:**
```{r}

```



**tidyverse:**
```{r}

sim_binom_ci <- function(size, prob =  p) {
  
}

```


### Margin of Error and Sample Size Calculation in Polls

**tidyverse** Write a function to calculate the sample size needed for a given proportion.
```{r}
moe_pop_prop <- function(MoE) {
  tibble(p = seq(from = 0.01, to = 0.99, by = 0.01),
         n = 1.96 ^ 2 * p * (1 - p) / MoE ^ 2,
         MoE = MoE)
}
moe_pop_prop(0.01)
```
Then use `r rdoc("purrr", "map_df")` to call this function for different margins of error, and return the entire thing as a data frame with columns: `n`, `p`, and `MoE`.
```{r}
MoE <- c(0.01, 0.03, 0.05)
props <- map_df(MoE, moe_pop_prop)
```
Since its a data frame, its easy to plot with `r rdoc("ggplot2", "ggplot")`:
```{r}
ggplot(props, aes(x = p, y = n, colour = factor(MoE))) +
  geom_line() +
  labs(colour = "margin of error",
       x = "population proportion",
       y = "sample size") +
  theme(legend.position = "bottom")
```


`r rdoc("readr", "read_csv")` already recognizes the date columns, so we don't need to convert them.
The 2008 election was on Nov 11, 2008, so we'll store that in a variable.
```{r message=FALSE}
ELECTION_DATE <- ymd(20081104)
```
Load the final vote shares,
```{r pres08}
data("pres08", package = "qss")
```
and polling data
```{r}
data("polls08", package = "qss")
```
We need to add an additional column to the `polls08` data frame which contains
the number of days until the election:
```{r}
polls08 <- polls08 %>%
  mutate(DaysToElection = as.integer(ELECTION_DATE - middate))
```
For each state calculate the mean of the latest polls,
```{r}
poll_pred <-
  polls08 %>%
  group_by(state) %>%
  # latest polls in the state
  filter(DaysToElection == min(DaysToElection)) %>%
  # take mean of latest polls and convert from 0-100 to 0-1
  summarise(Obama = mean(Obama) / 100)

# Add confidence itervals
# sample size
sample_size <- 1000
# confidence level
alpha <- 0.05
poll_pred <- 
  poll_pred %>%
  mutate(se = sqrt(Obama * (1 - Obama) / sample_size),
         ci_lwr = Obama + qnorm(alpha / 2) * se,
         ci_upr = Obama + qnorm(1 - alpha / 2) * se)

# Add actual outcome
poll_pred <-
  left_join(poll_pred, 
            select(pres08, state, actual = Obama), 
            by = "state") %>%
  mutate(actual = actual / 100,
         covers = (ci_lwr <= actual) & (actual <= ci_upr))
poll_pred
```


**tidyverse:** In the plot, color the point ranges by whether they include the election day outcome.
```{r}
ggplot(poll_pred, aes(x = actual, y = Obama,
                      ymin = ci_lwr, ymax = ci_upr,
                      colour = covers)) +
  geom_abline(intercept = 0, slope = 1, colour = "white", size = 2) +
  geom_pointrange() +
  scale_y_continuous("Poll prediction", limits = c(0, 1)) +
  scale_x_continuous("Obama's vote share", limits = c(0, 1)) +
  scale_colour_discrete("CI includes result?") +
  coord_fixed() +
  theme(legend.position = "bottom")
```
Proportion of polls with confidence intervals that include the election outcome?
```{r}
poll_pred %>% 
  summarise(mean(covers))
```


**tidyverse:**
```{r}
poll_pred <-
  poll_pred %>%
  # calc bias
  mutate(bias = Obama - actual) %>%
  # bias corrected prediction, se, and CI
  mutate(Obama_bc = Obama - mean(bias),
         se_bc = sqrt(Obama_bc * (1 - Obama_bc) / sample_size),
         ci_lwr_bc = Obama_bc + qnorm(alpha / 2) * se_bc,
         ci_upr_bc = Obama_bc + qnorm(1 - alpha / 2) * se_bc,
         covers_bc = (ci_lwr_bc <= actual) & (actual <= ci_upr_bc))

poll_pred %>%
  summarise(mean(covers_bc))
  
```



### Analyais of Randomized Controlled Trials

Load the `STAR` data from the **qss** package,
```{r message=FALSE}
data("STAR", package = "qss")
```

Add meaningful labels to the `classtype` variable:
```{r}
STAR <- STAR %>%
  mutate(classtype = factor(classtype,
                            labels = c("small class", "regular class",
                                       "regular class with aid")))
```

Summarize scores by classroom type:
```{r}
classtype_means <- 
  STAR %>%
  group_by(classtype) %>%
  summarise(g4reading = mean(g4reading, na.rm = TRUE))
```

Plot the distribution of scores by classroom type:
```{r}
classtypes_used <- c("small class", "regular class")
ggplot(filter(STAR,
              classtype %in% classtypes_used,
              !is.na(g4reading)),
       aes(x = g4reading, y = ..density..)) +
  geom_histogram(binwidth = 20) +
  geom_vline(data = filter(classtype_means, classtype %in% classtypes_used),
             mapping = aes(xintercept = g4reading), 
             colour = "white", size = 2) +
  facet_grid(classtype ~ .) + 
  labs(x = "Fourth grade reading score", y = "Density")
```


```{r}
alpha <- 0.05
star_estimates <- 
  STAR %>%
  filter(!is.na(g4reading)) %>%
  group_by(classtype) %>%
  summarise(n = n(),
            est = mean(g4reading),
            se = sd(g4reading) / sqrt(n)) %>%
  mutate(lwr = est + qnorm(alpha / 2) * se,
         upr = est + qnorm(1 - alpha / 2) * se)

star_estimates
```

```{r}
star_estimates %>%
  filter(classtype %in% c("small class", "regular class")) %>%
  # ensure that it is ordered small then regular
  arrange(desc(classtype)) %>%
  summarise(
    se = sqrt(sum(se ^ 2)),
    est = diff(est)
  ) %>%
  mutate(ci_lwr = est + qnorm(alpha / 2) * se,
         ci_up = est + qnorm(1 - alpha / 2) * se)
```

Use we could use `r rdoc("tidyr", "spread")` and `r rdoc("tidyr", "gather")`:
```{r}
star_ate <-
  star_estimates %>%
  filter(classtype %in% c("small class", "regular class")) %>%
  mutate(classtype = fct_recode(factor(classtype), 
                                "small" = "small class",
                                "regular" = "regular class")) %>%
  select(classtype, est, se) %>%
  gather(stat, value, -classtype) %>%
  unite(variable, stat, classtype)  %>%
  spread(variable, value) %>%
  mutate(ate_est = est_small - est_regular,
         ate_se = sqrt(se_small ^ 2 + se_regular ^ 2),
         ci_lwr = ate_est + qnorm(alpha / 2) * ate_se,
         ci_upr = ate_est + qnorm(1 - alpha / 2) * ate_se) 
star_ate 
```


### Analysis Based on Student's t-Distribution


Use `r rdoc("dplyr", "filter")` to subset.
```{r}
t.test(filter(STAR, classtype == "small class")$g4reading,
       filter(STAR, classtype == "regular class")$g4reading)
```
The function `r rdoc("stat", "t.test")` can also take a formula as its first parameter.
```{r}
t.test(g4reading ~ classtype,
       data = filter(STAR, classtype %in% c("small class", "regular class")))
```


## Hypothesis Testing

### Tea-Testing Experiment


```{r}
# Number of cups of tea
cups <- 4
# Number guessed correctly
k <- c(0, seq_len(cups))
true <-  tibble(correct = k * 2,
                n = choose(cups, k) * choose(cups, cups - k)) %>%
  mutate(prob = n / sum(n))
true
```


```{r}
sims <- 1000

guess <- tibble(guess = c("M", "T", "T", "M", "M", "T", "T", "M"))

randomize_tea <- function(df) {
  # randomize the order of teas
  assignment <- sample_frac(df, 1) %>%
    rename(actual = guess)
  bind_cols(df, assignment) %>%
    summarise(correct = sum(guess == actual))
}

approx <-
  map_df(seq_len(sims), ~ randomize_tea(guess)) %>%
  count(correct) %>%
  mutate(prob = n / sum(n))

left_join(select(approx, correct, prob_sim = prob),
          select(true, correct, prob_exact = prob),
          by = "correct") %>%
  mutate(diff = prob_sim - prob_exact)
```


### The General Framework

The test functions like `r rdoc("stat", "fisher.test")` do not work particularly well with data frames, and expect vectors or matrices as input, so tidyverse functions are less directly applicable

```{r}
# all guesses correct
x <- tribble(~Guess, ~Truth, ~Number,
             "Milk", "Milk", 4L,
             "Milk", "Tea", 0L,
             "Tea", "Milk", 0L,
             "Tea", "Tea", 4L)
x

# 6 correct guesses
y <- x %>%
  mutate(Number = c(3L, 1L, 1L, 3L))
y

# Turn into a 2x2 table for fisher.test
select(spread(x, Truth, Number), -Guess)

# Use spread to make it a 2 x 2 table
fisher.test(select(spread(x, Truth, Number), -Guess),
            alternative = "greater")
fisher.test(select(spread(y, Truth, Number), -Guess))
```

### One-Sample Tests

```{r}
n <- 1018
x.bar <- 550 / n
se <- sqrt(0.5 * 0.5 / n) # standard deviation of sampling distribution

## upper red area in the figure
upper <- pnorm(x.bar, mean = 0.5, sd = se, lower.tail = FALSE)  

## lower red area in the figure; identical to the upper area
lower <- pnorm(0.5 - (x.bar - 0.5), mean = 0.5, sd = se)  

## two-side p-value
upper + lower

2 * upper

## one-sided p-value
upper

z.score <- (x.bar - 0.5) / se
z.score

pnorm(z.score, lower.tail = FALSE) # one-sided p-value
2 * pnorm(z.score, lower.tail = FALSE) # two-sided p-value

## 99% confidence interval contains 0.5
c(x.bar - qnorm(0.995) * se, x.bar + qnorm(0.995) * se)

## 95% confidence interval does not contain 0.5
c(x.bar - qnorm(0.975) * se, x.bar + qnorm(0.975) * se)

## no continuity correction to get the same p-value as above
prop.test(550, n = n, p = 0.5, correct = FALSE)

## with continuity correction
prop.test(550, n = n, p = 0.5)
prop.test(550, n = n, p = 0.5, conf.level = 0.99)
```

```{r}
## two-sided one-sample t-test
t.test(STAR$g4reading, mu = 710)
```

### Two-sample tests

The ATE estimates are stored in a data frame, `star_ate`. Note that the `r pkg_link("dplyr")` function `r rdoc("dplyr", "transmute")` is like `mutate`, but only returns the variables specified in the function.
```{r}
star_ate %>%
  transmute(p_value_1sided = pnorm(-abs(ate_est),
                                   mean = 0, sd = ate_se),
            p_value_2sided = 2 * pnorm(-abs(ate_est), mean = 0, 
                                   sd = ate_se))

```

```{r}
t.test(g4reading ~ classtype,
  data = filter(STAR, classtype %in% c("small class", "regular class")))
```
or 
```{r}
t.test(filter(STAR, classtype == "small class")$g4reading,
       filter(STAR, classtype == "regular class")$g4reading)
```

```{r message=FALSE}
data("resume", package = "qss")

x <- resume %>%
  count(race, call) %>%
  spread(call, n) %>%
  ungroup()
x

prop.test(as.matrix(select(x, -race)), alternative = "greater")
```

**tidyverse:** 
```{r}
## sample size
n0 <- sum(resume$race == "black")
n1 <- sum(resume$race == "white")

## sample proportions
p <- mean(resume$call) # overall
p0 <- mean(filter(resume, race == "black")$call)
p1 <- mean(filter(resume, race == "white")$call)

## point estimate
est <- p1 - p0
est

## standard error
se <- sqrt(p * (1 - p) * (1 / n0 + 1 / n1))
se

## z-statistic
zstat <- est / se
zstat

## one-sided p-value
pnorm(-abs(zstat))
```
The only thing that changed is using `r rdoc("dplyr", "filter")` for selecting the groups.

### Power Analysis

```{r eval=FALSE}
## set the parameters
n <- 250
p.star <- 0.48 # data generating process
p <- 0.5 # null value
alpha <- 0.05

## critical value
cr.value <- qnorm(1 - alpha / 2) 

## standard errors under the hypothetical data generating process
se.star <- sqrt(p.star * (1 - p.star) / n)

## standard error under the null
se <- sqrt(p * (1 - p) / n)  

## power
pnorm(p - cr.value * se, mean = p.star, sd = se.star) + 
    pnorm(p + cr.value * se, mean = p.star, sd = se.star, lower.tail = FALSE)

## parameters
n1 <- 500
n0 <- 500
p1.star <- 0.05
p0.star <- 0.1

## overall call back rate as a weighted average
p <- (n1 * p1.star + n0 * p0.star) / (n1 + n0) 
## standard error under the null
se <- sqrt(p * (1 - p) * (1 / n1 + 1 / n0)) 
## standard error under the hypothetical data generating process
se.star <- sqrt(p1.star * (1 - p1.star) / n1 + p0.star * (1 - p0.star) / n0)

pnorm(-cr.value * se, mean = p1.star - p0.star, sd = se.star) + 
    pnorm(cr.value * se, mean = p1.star - p0.star, sd = se.star, 
          lower.tail = FALSE)

power.prop.test(n = 500, p1 = 0.05, p2 = 0.1, sig.level = 0.05)
power.prop.test(p1 = 0.05, p2 = 0.1, sig.level = 0.05, power = 0.9)
power.t.test(n = 100, delta = 0.25, sd = 1, type = "one.sample")
power.t.test(power = 0.9, delta = 0.25, sd = 1, type = "one.sample")
power.t.test(delta = 0.25, sd = 1, type = "two.sample", 
             alternative = "one.sided", power = 0.9)
```


## Linear Regression Model with Uncertainty

### Linear Regression as a Generative Model

Load the minimum wage date included with the **qss** package:
```{r message=FALSE}
data("minwage", package = "qss")
```
  
```{r}
minwage <- mutate(minwage,
                  fullPropBefore = fullBefore / (fullBefore + partBefore),
                  fullPropAfter = fullAfter / (fullAfter + partAfter),
                  NJ = as.integer(location == "PA"))
```


```{r}
fit_minwage <- lm(fullPropAfter ~ -1 + NJ + fullPropBefore +
                    wageBefore + chain, data = minwage)
fit_minwage
fit_minwage1 <- lm(fullPropAfter ~ NJ + fullPropBefore +
                     wageBefore + chain, data = minwage)
fit_minwage1

gather_predictions(slice(minwage, 1), fit_minwage, fit_minwage1) %>%
  select(model, pred)
```


### Inference about coefficients

Use the `r rdoc("broom", "tidy")` function to return the coefficients, including confidence intervals, as a data frame:
```{r message=FALSE}
data("women", package = "qss")
fit_women <- lm(water ~ reserved, data = women)
summary(fit_women)
tidy(fit_women)
```

You need to set `conf.int = TRUE` for `r rdoc("broom", "tidy.lm", "tidy")` to include the confidence interval:
```{r}
summary(fit_minwage)
tidy(fit_minwage, conf.int = TRUE)
```

### Inference about predictions

```{r message=FALSE}
data("MPs", package = "qss")
MPs_labour <- filter(MPs, party == "labour")
MPs_tory <- filter(MPs, party == "tory")
labour_fit1 <- lm(ln.net ~ margin, data = filter(MPs_labour, margin < 0))
labour_fit2 <- lm(ln.net ~ margin, data = filter(MPs_labour, margin > 0))
tory_fit1 <- lm(ln.net ~ margin, data = filter(MPs_tory, margin < 0))
tory_fit2 <- lm(ln.net ~ margin, data = filter(MPs_tory, margin > 0))
```


Predictions at the threshold. 
The `r pkg_link("broom")` function `r rdoc("broom", "augment")` will return prediction fitted values and standard errors for each value, but not the confidence intervals themselves (we'd have to multiply the correct t-distribution with degrees of freedom.)
So instead, we'll directly use the `r rdoc("stats", "predict.lm", "predict")` function:
```{r}
tory_y0 <-
  predict(tory_fit1, interval = "confidence", 
          newdata = tibble(margin = 0)) %>% as_tibble()
tory_y0

tory_y1 <-
  predict(tory_fit2, interval = "confidence", 
          newdata = tibble(margin = 0)) %>% as_tibble()
tory_y1
```
Alternatively, using `augment` (and assuming a normal distribution since the number of observations is so large its not worth worrying about the t-distribution):
```{r}
tory_y0 <-
  augment(tory_fit1, newdata = tibble(margin = 0)) %>%
  mutate(lwr = .fitted + qnorm(0.025) * .se.fit,
         upr = .fitted + qnorm(0.975) * .se.fit)
tory_y0

tory_y1 <-
  augment(tory_fit2, newdata = tibble(margin = 0)) %>%
  mutate(lwr = .fitted + qnorm(0.025) * .se.fit,
         upr = .fitted + qnorm(0.975) * .se.fit)
tory_y1
```

```{r}
y1_range <- data_grid(filter(MPs_tory, margin <= 0), margin)
tory_y0 <- augment(tory_fit1, newdata = y1_range)


y2_range <- data_grid(filter(MPs_tory, margin >= 0), margin)
tory_y1 <- augment(tory_fit2, newdata = y2_range)

```

```{r}
ggplot() +
  geom_ref_line(v = 0) +
  geom_point(aes(y = ln.net, x = margin), data = MPs_tory) +
  # plot losers
  geom_ribbon(aes(x = margin,
                  ymin = .fitted + qnorm(0.025) * .se.fit,
                  ymax = .fitted + qnorm(0.975) * .se.fit),
              data = tory_y0, alpha = 0.3) +  
  geom_line(aes(x = margin, y = .fitted), data = tory_y0) +
  # plot winners
  geom_ribbon(aes(x = margin,
                  ymin = .fitted + qnorm(0.025) * .se.fit,
                  ymax = .fitted + qnorm(0.975) * .se.fit),
              data = tory_y1, alpha = 0.3) +  
  geom_line(aes(x = margin, y = .fitted), data = tory_y1) +
  labs(x = "Margin of vitory", y = "log net wealth")
```

```{r}
tory_y1 <- augment(tory_fit1, newdata = tibble(margin = 0))
tory_y1
tory_y0 <- augment(tory_fit2, newdata = tibble(margin = 0))
tory_y0
summary(tory_fit1)
summary(tory_fit2)
```

Since we aren't doing anything more with these values, there isn't much benefit in keeping them in data frames.
I just adjust the names to be consistent with earlier code.
```{r}
# standard error
se_diff <- sqrt(tory_y0$.se.fit ^ 2 + tory_y1$.se.fit ^ 2)
se_diff

## point estimate
diff_est <- tory_y1$.fitted - tory_y0$.fitted
diff_est

## confidence interval
CI <- c(diff_est - se_diff * qnorm(0.975),
        diff_est + se_diff * qnorm(0.975))
CI

## hypothesis test
z.score <- diff_est / se_diff
p.value <- 2 * pnorm(abs(z.score), lower.tail = FALSE) # two-sided p-value
p.value
```

